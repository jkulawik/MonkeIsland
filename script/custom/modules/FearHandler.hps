//----------------------------------------------------------------------------------------

#include "interfaces/UserModule_Interface.hps"

#include "base/Player_Types.hps"
#include "base/InputHandler_Types.hps"

#include "helpers/helper_modules.hps"
#include "helpers/helper_map.hps"
#include "helpers/helper_player_custom.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_player.hps"
#include "helpers/helper_modules_custom.hps"

#include "helpers/helper_audio.hps"
#include "helpers/helper_effects.hps"
#include "helpers/helper_flashlight.hps"
#include "helpers/helper_items.hps"

#include "custom/components/ComponentInterfaces_Custom.hps"
#include "custom/modules/ModuleInterfaces_Custom.hps"
#include "custom/helpers/helper_effects_custom.hps"

//----------------------------------------------------------------------------------------
 
const bool gbUseTentacleEffect = true;
const float gfPermaFailFadeInTime = 3.35f;
const float gfPermaFailSceneDelay = 2.5f;
const float gfPermaFailTentaclePulseRate = 0.3f;
const float gfBabyKickFearReductionTime = 10.f;

float gfShake_NoiseSpeed = 8.f;
float gfShake_MinFadeInTime = 2.f;
float gfShake_MaxFadeInTime = 5.f;
float gfShake_MoveMul = 1.5f;
float[] gvFovShake_CapBaseStrength = {0.01f, 0.02f, 0.03f};
float gfFovShake_FearStrength = 0.0200f;
float[] gvRollShake_CapBaseStrength = {0.57f, 1.14f, 1.71f};
float gfRollShake_FearStrength = 1.14f;

float gfDarknessMaxFactor = 0.4f;
float gfDarknessMaxFactor_PostPF = 0.2f;

//----------------------------------------------------------------------------------------

const tString[] gvPermafailBabyEnts = {"pf_baby_unknown.ent", "pf_baby_4_month.ent", "pf_baby_6_month.ent"};

//----------------------------------------------------------------------------------------

bool gbFearSound_FearSystemLoop_Active = true;
tString gsFearSound_FearSystemLoop = "player/UI/fear_system/fear_system";
tString gsFearSoundParam_FearSystemLoop_1 = "FearLevel";
tString gsFearSoundParam_FearSystemLoop_2 = "FearRate";
tString gsFearSoundParam_FearSystemLoop_3 = "FearFocus";

bool gbFearSound_Breathing_Active = true;
tString gsFearSound_Breathing = "monke/Player/breaths/air_fear";
tString gsFearSoundParam_Breathing_1 = "FearRate";
tString gsFearSoundParam_Breathing_2 = "FearFocus";
tString gsFearSoundParam_Breathing_3 = "FearCap";
tString gsFearSoundParam_Breathing_4 = "FearLevel";

bool gbFearSound_FearAreaMusic_Active = true;
tString gsFearSound_FearAreaMusic = "player/UI/fear_system/fear_system_music";
tString gsFearSoundParam_FearAreaMusic_1 = "FearLevel";
tString gsFearSoundParam_FearAreaMusic_2 = "FearRate";

tString gsFearSound_Crouch = "player/vocalisations/fear/fear_crouch";
tString gsFearSound_Gasp = "monke/Player/breaths/air_fear";

bool gbFearSound_Crackling_Active = true;
tString gsFearSound_Crackling = "player/UI/sanity/sanity_loop";

tString gsFearSound_CapIncrease_1 = "player/UI/fear_system/warning_cough_phase_1";
tString gsFearSound_CapIncrease_2 = "player/UI/fear_system/warning_cough_phase_2";

bool gbFearSound_PermaFailWarning_Active = false;
tString gsFearSound_PermaFailWarning = "player/UI/fear_system/fear_siren_loop";

const tString gsStruggleLoopSound = "player/UI/permafail/hands_loop";
	
const tString gsStruggleGradingTexture = "grading_struggle_bright";	

bool gbFearSound_WhispersActive = false;
array<tString> gvFearWhisperNames = {
	"StartToSalim",				// eFearWhisperStage_StartToSalim,
	"SalimToRadio",				// eFearWhisperStage_SalimToRadio,
	"RadioToBabyKick",			// eFearWhisperStage_RadioToBabyKick,
	"BabyKickToOasis",			// eFearWhisperStage_BabyKickToOasis,
	"OasisToBabyKick",			// eFearWhisperStage_OasisToBabyKick,
	"BabyKickToHQA",			// eFearWhisperStage_BabyKickToHQA,
	"HQAToVitaeStation",		// eFearWhisperStage_HQAToVitaeStation,
	"VitaeStationToMilking",	// eFearWhisperStage_VitaeStationToMilking,
	"MilkingToDWFA",			// eFearWhisperStage_MilkingToDWFA,
	"DWFAToDWFC",				// eFearWhisperStage_DWFAToDWFC,
	"DWFCToTown",				// eFearWhisperStage_DWFCToTown,
	"TownToBirth",				// eFearWhisperStage_TownToBirth,
	"BirthToThroneRoom",		// eFearWhisperStage_BirthToThroneRoom,
	"ThroneRoomToEnd",			// eFearWhisperStage_ThroneRoomToEnd
};

const int WHISPER_COUNT=4;
const int WHISPER_SPECIFIC_COUNT=4;
const int WHISPER_GENERIC_COUNT=8;
const float WHISPER_DISTANCE=1.0f;
const float WHISPER_SPEAKER_SPREAD=20.0f;
const float WHISPER_MIN_DISTANCE=0.5f;
const float WHISPER_MAX_DISTANCE=1.5f;
const float WHISPER_ROTATE_DURATION=6.0f;
const float WHISPER_STAGGER_DURATION=3.5f;
const float WHISPER_STAGGER_DURATION_BOOSTED=0.25f;
const float WHISPER_START_LEVEL=0.67f;
const float WHISPER_CAP_BOOST = 1.25f;
const float WHISPER_CAP_BOOST_DURATION = 5.0f;
const float WHISPER_AUDIO_OVERWHELM_LEVEL = 0.98f;
const float WHISPER_AUDIO_DUCK_VOLUME = 0.5f;
const float WHISPER_AUDIO_DUCK_VOLUME_FADE = 0.25f;

//----------------------------------------------------------------------------------------

bool gbCanGasp = true;

//----------------------------------------------------------------------------------------

enum eFearObject
{
	eFearObject_ScaryObject,
	eFearObject_Threat,
	eFearObject_ThreatAgent,
}

//----------------------------------------------------------------------------------------

class cFearForcedFactor
{
	float mfForcedFactor = 0.0f;
	float mfForcedFactorTarget = 0.0f;
	float mfForcedFactorDurationTimer = 0.0f;
	float mfForcedFactorDuration = 0.0f;
	float mfForcedIncreaseSpeedUserValue = -1.0f;
	float mfForcedDecreaseSpeedUserValue = -1.0f;
	bool mbForcedDoGasp = false;
}

class cFearRateMul
{
	float mfTarget = 1.0f;
	float mfValue = 1.0f;
	float mfFadeTime = 0.0f;
}

//----------------------------------------------------------------------------------------

enum ePermaFailSceneType
{
	ePermaFailSceneType_None,
	ePermaFailSceneType_PlayerAnim,
	ePermaFailSceneType_PlayerMove,
	ePermaFailSceneType_CameraAnim
}

//----------------------------------------------------------------------------------------

class cPermaFailScene
{
	float mfDuration;
	float mfMoveSpeed;
	bool mbRandomLookDirActive;
	bool mbCrouch;
	cVector3f mvMoveStart;
	cVector3f mvMoveEnd;
	tString msPlayerAnim;
	tString msEntity;
	tString msAnimEntity;
	tString msEntityAnim;
	tString msCameraAnim;
	int mlType;
}

//----------------------------------------------------------------------------------------

class cPermaFailSenario
{
	array<cPermaFailScene> mvScenes;
	bool mbGeneric = false;
}

//----------------------------------------------------------------------------------------

class cScrFearHandler : iScrUserModule, iScrUserModule_Interface, iScrFearHandler_Interface
{
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INIT
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Init()
	{
		mbVfx_FOVShakesEnabled = cLux_GetUserConfig().GetBool("Gameplay", "ScreenDisortion", true);
		mvRateMuls.resize(eFearRateMulType_LastEnum);
	}
		
	//------------------------------------------------------------
	
	void LoadUserConfig()
	{
		mbVfx_FOVShakesEnabled = cLux_GetUserConfig().GetBool("Gameplay", "ScreenDisortion", true);
	}
	
	//------------------------------------------------------------
	
	void SaveUserConfig()
	{
	}
	
	
	//------------------------------------------------------------
	
	//} END OF INIT
	
	/////////////////////////////////////////
	// INTERFACE
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	bool raise = false;
	void Debug()
	{
		cLux_AddDebugMessage("[FearHandler] Fear Objects: " + GetFearObjectCount());
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFear = GetFearObjects()[i];
			iLuxEntity@ pEnt = cLux_ID_Entity(pFear.m_idEntity);
		}
/*		raise = !raise;
		if (raise)
		{
			FadeLevelTo(1.0f, 10.0f, true);
		}
		else
		{
			FadeLevelTo(0.0f, 10.0f, true);
		}*/
	}
	
	//------------------------------------------------------------
	
	void SetActive(bool abActive)
	{
		mbActive = abActive;
		
		// TODO: Move this to some nicer place, Yours truly, Edvin
		if(abActive && gbUseTentacleEffect)
			Effect_FearTentacles_Start();
		else
			Effect_FearTentacles_Stop();
			
		if (!mbActive)
		{
			if (m_idAudio_Crackling != tID_Invalid)
			{
				cSoundEntity@ pSound = cLux_ID_SoundEntity(m_idAudio_Crackling);
				if (pSound !is null)
				{
					pSound.FadeVolumeMul(0.0f, 2.0f);
				}
			}
			
			for (uint i=0;i<mvWhisperIDs.size();i++)
			{
				if (mvWhisperIDs[i]==tID_Invalid)
					continue;
				cSoundEntity@ pSound = cLux_ID_SoundEntity(mvWhisperIDs[i]);
				if (pSound !is null)
				{
					pSound.FadeVolumeMul(0.0f,2.0f);
				}
			}
		}
	}
	
	//------------------------------------------------------------
	
	bool GetIsActive()
	{
		return mbActive;
	}
	
	//------------------------------------------------------------
	
	void SetPaused(bool abPaused)
	{
		mbPaused = abPaused;
	}

	//------------------------------------------------------------
	
	bool GetPaused()
	{
		return mbPaused;
	}
	
	//------------------------------------------------------------
	
	bool IsInitialized()
	{
		return mbInitialized;
	}
	
	//------------------------------------------------------------
	
	void SetDefaultState(eFearAreaState aState)
	{
		mDefaultState = aState;
		if (mActiveFearArea.m_idArea == tID_Invalid) mFearAreaState = mDefaultState;
	}
	
	//------------------------------------------------------------
	
	void SetUpdateInterval(float afInterval)
	{
		if (mfFearObject_UpdateInterval == afInterval) return;
		mfFearObject_UpdateInterval = afInterval;
		if (afInterval <= 0) mfFearObject_UpdateInterval = 0.21f;
		InitFearObjectUpdateInterval();
	}
	
	//------------------------------------------------------------
	
	void RegisterScaryObject(cFearScaryObjectParams@ apFearObject)
	{
		cFearScaryObject newObject(apFearObject);
		newObject.Init();
		mvScaryObjects.push_back(newObject);
		mbRebuildFearObjectRefs = true;
//		cLux_AddDebugMessage("FH SO " + mvScaryObjects.size());
	}
	
	//------------------------------------------------------------
	
	void RegisterThreat(cFearThreatParams@ apFearObject)
	{
		cFearThreat newObject(apFearObject);
		newObject.Init();
		mvThreats.push_back(newObject);
		mbRebuildFearObjectRefs = true;
//		cLux_AddDebugMessage("FH TO " + mvThreats.size());
	}
	
	//------------------------------------------------------------
	
	void RegisterThreatAgent(cFearThreatParams@ apFearObject)
	{
		cFearThreatAgent newObject(apFearObject);
		newObject.Init();
		mvThreatAgents.push_back(newObject);
		mbRebuildFearObjectRefs = true;
//		cLux_AddDebugMessage("FH TA " + mvThreatAgents.size());
	}
	
	//------------------------------------------------------------
	
	void RegisterFearArea(cFearAreaParams@ apFearArea)
	{
		cLux_AddDebugMessage("[FearHandler] Start RegisterFearArea " + mvFearAreas.size());
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			iLuxEntity@ pEnt = cLux_ID_Entity(mvFearAreas[i].m_idArea);
			if (pEnt is null)
			{
				cLux_AddDebugMessage("[FearHandler] Remove it because a corrupted version was saved");
				mvFearAreas.removeAt(i);
				continue;
			}
			if (apFearArea.m_idArea == mvFearAreas[i].m_idArea) return;
		}
		
		cFearAreaInfo newArea;
		newArea.m_idArea = apFearArea.m_idArea;
		newArea.msMap = apFearArea.msMap;
		newArea.mlPriority = apFearArea.mlPriority;
		newArea.mlAddedId = 0;
		newArea.mbSafe = apFearArea.mbSafe;
		newArea.mbNoFear = apFearArea.mbNoFear;
		newArea.mbDarknessFear = apFearArea.mbDarknessFear;
		newArea.mfBabyKickRateMultiplier = apFearArea.mfBabyKickRateMultiplier;
		newArea.mbLocked = apFearArea.mbLocked;
		newArea.msUnsafeMusic = apFearArea.msUnsafeMusic;
		newArea.msSafeMusic = apFearArea.msSafeMusic;
		newArea.mfNonAgentRateCap = apFearArea.mfNonAgentRateCap;
		newArea.mbAllowProgressWithToken = apFearArea.mbAllowProgressWithToken;
		newArea.mbAllowProgressWithoutToken = apFearArea.mbAllowProgressWithoutToken;
		newArea.mlMaxProgressCount = apFearArea.mlMaxProgressCount;
		newArea.mlProgressAmount = apFearArea.mlProgressAmount;
		mvFearAreas.push_back(newArea);
		
		iLuxEntity@ pEnt = cLux_ID_Entity(newArea.m_idArea);
		tString sAreaName = (pEnt is null) ? "" : pEnt.GetName();
		cLux_AddDebugMessage("[FearHandler] RegisterFearArea: " + sAreaName + " " + newArea.m_idArea + " " + mvFearAreas.size());
	}
	
	//------------------------------------------------------------
	
	void RegisterFearRateArea(cFearRateAreaParams@ apFearRateArea)
	{
		cFearRateAreaInfo newArea;
		newArea.m_idArea = apFearRateArea.m_idArea;
		newArea.msMap = apFearRateArea.msMap;
		newArea.mfFearRate = apFearRateArea.mfFearRate;
		newArea.mlPriority = apFearRateArea.mlPriority;
		newArea.mfIncreaseSpeed = apFearRateArea.mfIncreaseSpeed;
		newArea.mfDecreaseSpeed = apFearRateArea.mfDecreaseSpeed;
		mvFearRateAreas.push_back(newArea);
	}
	
	//------------------------------------------------------------
	
	void SetDarknessFactorActive(bool abX)
	{
		mbDarknessActive = abX;
	}
	
	//------------------------------------------------------------
	
	void ForceUnderwaterFear(bool abX)
	{
		mbForceUnderwaterFear = abX;
	}
	
	//------------------------------------------------------------
	
	float GetLevel()
	{
		return mfLevel;
	}
	
	//------------------------------------------------------------
	
	void SetDifficultyMul(float afMul)
	{
		mfDifficultyMul = afMul;
	}
	
	//------------------------------------------------------------
	
	bool IsAgentNearby()
	{
		return (mfThreatAgentFactor>0.0f);
	}
	
	//------------------------------------------------------------
	
	void SetMaxLevel(float afMax)
	{
		mfMaxLevel = afMax;
	}
	
	//------------------------------------------------------------
	
	void ResetMaxLevel()
	{
		mfMaxLevel = 1.f;
	}
	
	//------------------------------------------------------------
	
	float GetRate()
	{
		return mfRate;
	}
	
	//------------------------------------------------------------
	
	float GetMaxNonAgentRateCap()
	{
		float fMax = 0.0f;
		for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
		{
			fMax = cMath_Max(fMax, mvInsideFearAreas[i].mfNonAgentRateCap);
		}
		return fMax;
	}
	
	//------------------------------------------------------------
	
	void SetAverageBrightness(bool abActive)
	{
		mbDarknessAverageActive = abActive;
		cLux_SetComputeAverageFrameColor(abActive);
	}
	
	//------------------------------------------------------------
	
	void SetForcedAddFearRate(uint alId, float afFearRate, float afDuration = -1.0f, bool abGasp = true, float afIncreaseSpeed = -1.0f, float afDecreaseSpeed = -1.0f, float afDelay = 0.0f)
	{
		if (mvForcedFactors.size() <= alId)
			mvForcedFactors.resize(alId + 1);
        
		mvForcedFactors[alId].mfForcedFactorTarget = afDuration < 0 ? 0 : afFearRate;
		mvForcedFactors[alId].mfForcedFactorDuration = afDuration;
		
		if (afDuration < 0) mvForcedFactors[alId].mfForcedFactorDurationTimer = 0;
		else mvForcedFactors[alId].mfForcedFactorDurationTimer = afDelay + afDuration;
		
		mvForcedFactors[alId].mfForcedIncreaseSpeedUserValue = afIncreaseSpeed;
		mvForcedFactors[alId].mfForcedDecreaseSpeedUserValue = afDecreaseSpeed;
		mvForcedFactors[alId].mbForcedDoGasp = abGasp;		
	}
	
	//------------------------------------------------------------
	
	void AddProgressToken()
	{
		mbProgressToken = true;
	}
	
	//------------------------------------------------------------
	
	float mfGaspCooldown = 0.0f;
	bool PlayGasp(float afPrevContrib, float afContrib, bool abDelay = false)
	{
		float fDiff = afContrib - afPrevContrib;
		if (fDiff < 0.4f) return false;
		if (mfGaspCooldown <= 0.0f)
		{
			mfGaspCooldown = 10.0f;
			// Last-minute hack - removing delay, because lots of people complained that
			// gasps were coming in too late. - IT
			abDelay = false;
			mBaseObj.Timer_Add("PlayFearGasp", abDelay ? 0.4f : 0.0f, "OnTimer_PlayFearGasp", false);
		}
		return true;
	}
	
	void OnTimer_PlayFearGasp(uint64 alID)
	{
		PlayerEmotion_PlaySound(eEmotionPlaylistType_Breathing, eEmotionSoundType_OneShotEvent, 1, gsFearSound_Gasp, -1, 0.1, 1);
	}
	
	//------------------------------------------------------------
	
	void SetLevelTo(float afLevel)
	{
		mfLevel = cMath_Clamp(afLevel, 0.0f, 1.0f);
	}
	
	//------------------------------------------------------------
	
	void FadeLevelTo(float afLevel, float afFadeTime, bool abIgnoreRegenCap = true)
	{
		if (afFadeTime <= 0.0f)
		{
			afFadeTime = 0.01f;
		}
		mfLevelFade_Target = cMath_Clamp(afLevel, abIgnoreRegenCap ? 0.0f : GetCurrentLevelRegenCap(), 1.0f);
		mfLevelFade_FadeTimer = afFadeTime;
		mfLevelFade_Speed = (1.0f / afFadeTime) * cMath_Abs(mfLevel - mfLevelFade_Target);
		mbLevelFade_IgnoreRegenCap = abIgnoreRegenCap;
		if (mbLevelFade_IgnoreRegenCap)
		{
			mbLevelRegenCapActive = false;
		}
		mbLevelFade_Active = true;
	}
	
	//------------------------------------------------------------
	
	void FadeRateMulTo(eFearRateMulType aType, float afMul, float afFadeTime)
	{
		cFearRateMul@ pMul = mvRateMuls[aType];
		pMul.mfTarget = afMul;
		if (afFadeTime <= 0)
		{
			pMul.mfValue = pMul.mfTarget;
			afFadeTime = 0;
		}
		pMul.mfFadeTime = afFadeTime;
	}
	
	//------------------------------------------------------------
	
	void IncreaseLevel(float afAmount, const tString&in asSource, bool abIgnoreRegenCap = true, bool abDoIntro = true)
	{
		mfLevel += afAmount;
		if (!abIgnoreRegenCap)
			mfLevel = cMath_Clamp(mfLevel, GetCurrentLevelRegenCap(), mfMaxLevel);
		
		if (mfLevel >= 1.f && mbPermaFail_Active == false)
		{
			if (abDoIntro && cLux_GetPlayer().GetCurrentStateId() == ePlayerState_Custom_Thrown)
			{
				mbPermaFail_TriggerWhenInNormalState = true;
				msPermafail_Source = asSource;
				return;
			}
			
			TriggerPermaFail(abDoIntro, asSource);
		}
	}
	
	//------------------------------------------------------------
	
	void PlayerHearAgent(const cVector3f &in avPosition, float afRadius)
	{
		for (uint i = 0; i < mvThreatAgents.size(); ++i)
		{
			cFearThreatAgent@ pFearObject = mvThreatAgents[i];
			iLuxEntity@ pEnt = cLux_ID_Entity(pFearObject.m_idEntity);
			if (pEnt is null || pEnt.IsActive() == false) continue;
			cVector3f vAgentPos = pEnt.GetMeshEntity().GetWorldPosition();
			if (cMath_Abs(vAgentPos.y - avPosition.y) >= 2.0f) continue;
			if (cMath_Vector3Dist(avPosition, vAgentPos) > 0.4f) continue;
			if (cMath_Vector3Dist(avPosition, Player_GetPosition()) > afRadius) continue;
			pFearObject.HeardByPlayer();
		}
	}
	
	//------------------------------------------------------------
	
	void SetFearLevelRateMul(float afMul)
	{
		mfFearLevelRateMul = afMul;
	}
	
	//------------------------------------------------------------
	
	void SetCanGasp(bool abX)
	{
		gbCanGasp = abX;
	}
	
	//------------------------------------------------------------
	
	void SetFearTentaclesMul(float afMul)
	{
		mfFearTentaclesMul = afMul;
	}
	
	//------------------------------------------------------------
	
	float GetFearTentaclesMul()
	{
		return mfFearTentaclesMul;
	}
	
	//------------------------------------------------------------
	
	int GetFearAreaState()
	{
		return mFearAreaState;
	}
	
	//------------------------------------------------------------
	
	tID GetActiveFearArea()
	{
		return mActiveFearArea.m_idArea;
	}
	
	//------------------------------------------------------------
	
	bool IsInDarknessArea()
	{
		if (mFearAreaState == eFearAreaState_Safe) return false;
		if (mActiveFearArea.m_idArea != tID_Invalid && mActiveFearArea.mbDarknessFear == false) return false;
		return true;
	}
	
	//------------------------------------------------------------
	
	void SetFearAreaSafe(const tString &in asName, bool abSafe)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mbSafe = abSafe;
		}
		
		for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvInsideFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mbSafe = abSafe;
		}
		
		if (mActiveFearArea.m_idArea == pEnt.GetID())
		{
			mActiveFearArea.mbSafe = abSafe;
			UpdateFearAreaState();
		}
	}
	
	void SetFearAreaGivesFear(const tString &in asName, bool abGivesFear)
	{
		bool bNoFear = !abGivesFear;
		
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mbNoFear = bNoFear;
		}
		
		for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvInsideFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mbNoFear = bNoFear;
		}
		
		if (mActiveFearArea.m_idArea == pEnt.GetID())
		{
			mActiveFearArea.mbNoFear = bNoFear;
			UpdateFearAreaState();
		}
	}
	
	bool GetFearAreaSafe(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return false;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.mbSafe;
		}
		return false;
	}
	
	float GetFearAreaBabyKickRateMul(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return 1.f;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.mfBabyKickRateMultiplier;
		}
		
		return 1.f;
	}
	
	float GetCurrFearAreaBabyKickRateMul()
	{
		if (mActiveFearArea is null) return 1.f;
		return mActiveFearArea.mfBabyKickRateMultiplier;
	}
	
	void SetFearAreaLocked(const tString &in asName, bool abLocked)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mbLocked = abLocked;
		}
		
		for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvInsideFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mbLocked = abLocked;
		}
		
		if (mActiveFearArea.m_idArea == pEnt.GetID())
		{
			mActiveFearArea.mbLocked = abLocked;
			UpdateFearAreaState();
		}
	}
	
	bool GetFearAreaLocked(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return false;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.mbLocked;
		}
		return false;
	}
	
	void SetFearAreaUnsafeMusic(const tString &in asName, const tString &in msMusic)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.msUnsafeMusic = msMusic;
		}
		
		for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvInsideFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.msUnsafeMusic = msMusic;
		}
		
		if (mActiveFearArea.m_idArea == pEnt.GetID())
		{
			if (mActiveFearArea.msUnsafeMusic != msMusic) mlFearAreaMusicState = -1;
			mActiveFearArea.msUnsafeMusic = msMusic;
		}
	}
	
	tString GetFearAreaUnsafeMusic(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return "";
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.msUnsafeMusic;
		}
		return "";
	}
	
	void SetFearAreaSafeMusic(const tString &in asName, const tString &in msMusic)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.msSafeMusic = msMusic;
		}
		
		for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvInsideFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.msSafeMusic = msMusic;
		}
		
		if (mActiveFearArea.m_idArea == pEnt.GetID())
		{
			if (mActiveFearArea.msSafeMusic != msMusic) mlFearAreaMusicState = -1;
			mActiveFearArea.msSafeMusic = msMusic;
		}
	}
	
	tString GetFearAreaSafeMusic(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return "";
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.msSafeMusic;
		}
		return "";
	}
	
	bool GetFearAreaDarknessFear(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFear");
		if (pEnt is null) return false;
		
		for (uint i = 0; i < mvFearAreas.size(); ++i)
		{
			cFearAreaInfo@ pInfo = mvFearAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.mbDarknessFear;
		}
		return false;
	}
	
	//------------------------------------------------------------
	
	float GetFearAreaSafeMusicVol()
	{
		return mfSafeMusicVol;
	}
	
	//------------------------------------------------------------
	
	void SetFearRateAreaRate(const tString &in asName, float afRate)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFearRate");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearRateAreas.size(); ++i)
		{
			cFearRateAreaInfo@ pInfo = mvFearRateAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mfFearRate = afRate;
		}
		
		if (mActiveFearRateArea.m_idArea == pEnt.GetID())
		{
			mActiveFearRateArea.mfFearRate = afRate;
		}
	}
	
	float GetFearRateAreaRate(const tString &in asName)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFearRate");
		if (pEnt is null) return -1.0f;
		
		for (uint i = 0; i < mvFearRateAreas.size(); ++i)
		{
			cFearRateAreaInfo@ pInfo = mvFearRateAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			return pInfo.mfFearRate;
		}
		
		return -1.0f;
	}
	
	void SetFearAreaPriority(const tString &in asName, int alPriority)
	{
		iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(asName, eLuxEntityType_Area, "cScrAreaFearRate");
		if (pEnt is null) return;
		
		for (uint i = 0; i < mvFearRateAreas.size(); ++i)
		{
			cFearRateAreaInfo@ pInfo = mvFearRateAreas[i];
			if (pInfo.m_idArea != pEnt.GetID()) continue;
			pInfo.mlPriority = alPriority;
		}
		
		if (mActiveFearRateArea.m_idArea == pEnt.GetID())
		{
			mActiveFearRateArea.mlPriority = alPriority;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentEnabled_ScaryObject(const tString&in asEntity, bool abEnabled) { SetComponentEnabled(eFearObject_ScaryObject, asEntity, abEnabled); }
	void SetComponentEnabled_Threat(const tString&in asEntity, bool abEnabled) { SetComponentEnabled(eFearObject_Threat, asEntity, abEnabled); }
	void SetComponentEnabled_ThreatAgent(const tString&in asEntity, bool abEnabled) { SetComponentEnabled(eFearObject_ThreatAgent, asEntity, abEnabled); }
	
	void SetComponentEnabled(eFearObject amType, const tString&in asEntity, bool abEnabled)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.mType != amType) continue;
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.SetEnabled(abEnabled);
		}
	}
	
	//------------------------------------------------------------

	void SetComponentFearRateBoost_ScaryObject(const tString&in asEntity, float afAmount, float afTime, bool abGasp = true, float afIncreaseSpeed = -1.0f, float afDecreaseSpeed = -1.0f, float afDelay = 0.0f)
		{ SetComponentFearRateBoost(eFearObject_ScaryObject, asEntity, afAmount, afTime, abGasp, afIncreaseSpeed, afDecreaseSpeed, afDelay); }
	void SetComponentFearRateBoost_Threat(const tString&in asEntity, float afAmount, float afTime, bool abGasp = true, float afIncreaseSpeed = -1.0f, float afDecreaseSpeed = -1.0f, float afDelay = 0.0f)
		{ SetComponentFearRateBoost(eFearObject_Threat, asEntity, afAmount, afTime, abGasp, afIncreaseSpeed, afDecreaseSpeed, afDelay); }
	void SetComponentFearRateBoost_ThreatAgent(const tString&in asEntity, float afAmount, float afTime, bool abGasp = true, float afIncreaseSpeed = -1.0f, float afDecreaseSpeed = -1.0f, float afDelay = 0.0f)
		{ SetComponentFearRateBoost(eFearObject_ThreatAgent, asEntity, afAmount, afTime, abGasp, afIncreaseSpeed, afDecreaseSpeed, afDelay); }
		
	void SetComponentFearRateBoost(eFearObject amType, const tString&in asEntity, float afAmount, float afTime, bool abGasp = true, float afIncreaseSpeed = -1.0f, float afDecreaseSpeed = -1.0f, float afDelay = 0.0f)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.mType != amType) continue;
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.SetFearRateBoost(afAmount, afTime, abGasp, afIncreaseSpeed, afDecreaseSpeed, afDelay);
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentManualFearActivation_ScaryObject(const tString&in asEntity, bool abX) { SetComponentManualFearActivation(eFearObject_ScaryObject, asEntity, abX); }
	void SetComponentManualFearActivation_Threat(const tString&in asEntity, bool abX) { SetComponentManualFearActivation(eFearObject_Threat, asEntity, abX); }
	void SetComponentManualFearActivation_ThreatAgent(const tString&in asEntity, bool abX) { SetComponentManualFearActivation(eFearObject_ThreatAgent, asEntity, abX); }
	
	void SetComponentManualFearActivation(eFearObject amType, const tString&in asEntity, bool abX)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.mType != amType) continue;
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mbManualActivation = abX;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentFearActive_ScaryObject(const tString&in asEntity, bool abActive) { SetComponentFearActive(eFearObject_ScaryObject, asEntity, abActive); }
	void SetComponentFearActive_Threat(const tString&in asEntity, bool abActive) { SetComponentFearActive(eFearObject_Threat, asEntity, abActive); }
	void SetComponentFearActive_ThreatAgent(const tString&in asEntity, bool abActive) { SetComponentFearActive(eFearObject_ThreatAgent, asEntity, abActive); }
	
	void SetComponentFearActive(eFearObject amType, const tString&in asEntity, bool abActive)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.mType != amType) continue;
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mbFearActive = abActive;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentSurpriseFactor_ScaryObject(const tString&in asEntity, float afFactor) { SetComponentSurpriseFactor(eFearObject_ScaryObject, asEntity, afFactor); }
	void SetComponentSurpriseFactor_Threat(const tString&in asEntity, float afFactor) { SetComponentSurpriseFactor(eFearObject_Threat, asEntity, afFactor); }
	void SetComponentSurpriseFactor_ThreatAgent(const tString&in asEntity, float afFactor) { SetComponentSurpriseFactor(eFearObject_ThreatAgent, asEntity, afFactor); }
	
	void SetComponentSurpriseFactor(eFearObject amType, const tString&in asEntity, float afFactor)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.mType != amType) continue;
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfSurpriseFactor = afFactor;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentLookAtFactor_ScaryObject(const tString&in asEntity, float afFactor) { SetComponentLookAtFactor(eFearObject_ScaryObject, asEntity, afFactor); }
	void SetComponentLookAtFactor_Threat(const tString&in asEntity, float afFactor) { SetComponentLookAtFactor(eFearObject_Threat, asEntity, afFactor); }
	void SetComponentLookAtFactor_ThreatAgent(const tString&in asEntity, float afFactor) { SetComponentLookAtFactor(eFearObject_ThreatAgent, asEntity, afFactor); }
	
	void SetComponentLookAtFactor(eFearObject amType, const tString&in asEntity, float afFactor)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.mType != amType) continue;
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfLookAtFactor = afFactor;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentBaseFearRate_ThreatAgent(const tString&in asEntity, float afFearRate)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfBaseFearRate = afFearRate;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentBaseFearRateMul_ThreatAgent(const tString&in asEntity, float afFearRateMul)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfBaseFearRateMul = afFearRateMul;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentOverrideFactor_ThreatAgent(const tString&in asEntity, float afFactor)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfOverrideFactor = afFactor;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentActivationDistance_ThreatAgent(const tString&in asEntity, float afDistance)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfActivationDistance = afDistance;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentDeactivationDistance_ThreatAgent(const tString&in asEntity, float afDistance)
	{
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfDeactivationDistance = afDistance;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentMaxFearDistance_ThreatAgent(const tString&in asEntity, float afDistance)
	{
		for (uint i = 0; i < mvThreatAgents.size(); ++i)
		{
			cFearThreatAgent@ pFearObject = mvThreatAgents[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mfMaxFearDist = afDistance;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetComponentCanGasp_ScaryObject(const tString&in asEntity, bool abX)
	{
		for (uint i = 0; i < mvScaryObjects.size(); ++i)
		{
			cFearScaryObject@ pFearObject = mvScaryObjects[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mbCanGasp = abX;
			return;
		}
	}
	
	void SetComponentCanGasp_Threat(const tString&in asEntity, bool abX)
	{
		for (uint i = 0; i < mvThreats.size(); ++i)
		{
			cFearThreat@ pFearObject = mvThreats[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mbCanGasp = abX;
			return;
		}
	}
	
	void SetComponentCanGasp_ThreatAgent(const tString&in asEntity, bool abX)
	{
		for (uint i = 0; i < mvThreatAgents.size(); ++i)
		{
			cFearThreatAgent@ pFearObject = mvThreatAgents[i];
			if (pFearObject.GetEntityName() != asEntity) continue;
			pFearObject.mbCanGasp = abX;
			return;
		}
	}
	
	//------------------------------------------------------------
	
	eFearWhisperStage mWhisperStage = eFearWhisperStage_StartToSalim;
	bool mbWhispersActive = true;
	bool mbWhisperDuckApplied = false;
	[nosave] int mlWhisperIndex = 0;
	[nosave] array<tID> mvWhisperIDs;
	array<cVector3f> mvWhisperRotations;
	array<float> mvWhisperCurrents;	// For hysterisis - this is the current number, slowly approaching the target number.
	float mfWhisperTimer = 0.0f;
	float mfWhisperCooldown = 0.0f;
	float mfWhisperCapBoost = 0.0f;
	float mfWhisperDecreaseSpeed = 0.f;
	
	//------------------------------------------------------------
	
	void SetWhisperStage(eFearWhisperStage stage)
	{
		mWhisperStage = stage;
	}
	
	//------------------------------------------------------------
	
	void SetWhispersActive(bool aVal)
	{
		mbWhispersActive = aVal;
	}
	
	//------------------------------------------------------------
	
	void SetWhispersDecreaseSpeed(float afSpeed)
	{
		mfWhisperDecreaseSpeed = afSpeed;
	}
	
	//------------------------------------------------------------
	
	void UpdateWhispers(float afTimeStep)
	{
		float fActualStep = afTimeStep*10.0f;	// Because this is only called once every 10 frames. Very approx!
					
		mfWhisperTimer+=fActualStep;
				
		mlWhisperIndex++;
		if (mlWhisperIndex>=WHISPER_COUNT)
			mlWhisperIndex=0;
		
		while (mvWhisperIDs.size()<uint(mlWhisperIndex+1))
		{
			mvWhisperIDs.push_back(tID_Invalid);
			mvWhisperRotations.push_back(cVector3f_Forward);
			mvWhisperCurrents.push_back(0.0f);
			mfWhisperCooldown=0.0f;
		}
		
		if (mfWhisperCapBoost>0.0f)
		{
			mfWhisperCapBoost-=fActualStep/WHISPER_CAP_BOOST_DURATION;
			if (mfWhisperCapBoost<0.0f)
				mfWhisperCapBoost=0.0f;
		}
		
		if (mfWhisperCooldown>0.0f)
		{
			mfWhisperCooldown-=fActualStep;
		}
		
		float fBoost = cMath_Easing(eEasing_QuadIn, mfWhisperCapBoost);
			
		tString sSoundEntity = "FearSound_Whisper"+mlWhisperIndex;
		
		if (mvWhisperIDs[mlWhisperIndex] == tID_Invalid)
		{
			if (!mbWhispersActive)
				return;
				
			// Fear too low to play a whisper AND no artifical boost
			if ((mfLevel<WHISPER_START_LEVEL)&&(fBoost<=0.0f))
				return;
			
			if (mfWhisperCooldown>0.0f)
			{
				return;
			}	
			
			if (fBoost>0.0f)
				mfWhisperCooldown = WHISPER_STAGGER_DURATION_BOOSTED;
			else
				mfWhisperCooldown = WHISPER_STAGGER_DURATION;
				
			tString sFearSoundName = "";
			if (mlWhisperIndex<2)	//Sound 1 and 2 are specific
			{
				sFearSoundName = "FearWhisper_"+gvFearWhisperNames[mWhisperStage];
			}
			else
			{
				sFearSoundName = "FearWhisper_Generic";
			}
			
			cSoundEntity@ pSound = null;
			
			cLuxMap@ pMap = cLux_GetCurrentMap();
			if(pMap !is null)
				@pSound = pMap.GetWorld().CreateSoundEntity(sSoundEntity, "game_voice/FearWhisper/"+sFearSoundName, true);
				
			if (pSound !is null)
			{
				mvWhisperIDs[mlWhisperIndex]=pSound.GetID();
				
				// Set up sound file.
				pSound.SetScriptableIsSaved(false);
				pSound.SetVolume(0.0f);
				pSound.SetReverbAmount(1.0f);
				pSound.SetSpeakerSpread(cMath_ToRad(WHISPER_SPEAKER_SPREAD));
				pSound.SetSoundFileStream(true);
				pSound.SetSoundFileEntryType(eSoundEntryType_World);
				pSound.SetSoundFilePriority(255);
				pSound.SetSoundFile3D(true);
				pSound.SetCustomMinDistance(WHISPER_MIN_DISTANCE);
				pSound.SetCustomMaxDistance(WHISPER_MAX_DISTANCE);
				pSound.FadeVolumeMul(0.0f, 0.0f);
				
				mvWhisperRotations[mlWhisperIndex] = cMath_RandomSphereSurfacePoint(1.0f);
				
				UpdateWhisperPosition(pSound);
			}
		}
		else
		{
			cSoundEntity@ pSound = cLux_ID_SoundEntity(mvWhisperIDs[mlWhisperIndex]);
			if (pSound is null)
			{
				mvWhisperIDs[mlWhisperIndex] = tID_Invalid;
			}
			else
			{
				float fWhisperTarget = 0.0f;
				
				if (!mbWhispersActive||Sketchbook_IsFlashbackActive()||Sketchbook_IsMicroflashActive())
				{
					fWhisperTarget = 0.0f;
				}
				else if (mbWhispersActive && mfLevel>=WHISPER_START_LEVEL && mfRate>=0.01f)
				{
					// Basic level of fear = 0.0f to 1.0f
					float fLevel = cMath_Clamp((mfLevel-WHISPER_START_LEVEL)/(1.0f-WHISPER_START_LEVEL),0.0f,1.0f);
		
					// Slow general pulse = 0.0f to 1.0f
					float fAngle1 = 360.0f*mfWhisperTimer/(10.0f*(1.1f-fLevel));
					float fPulse1 = (cMath_Sin(cMath_ToRad(fAngle1)) + 1.0f) * 0.5f;
					
					// Faster whisper-specific pulse = 0.0f to 1.0f
					float fAngle2 = (360.0f/WHISPER_COUNT)*mlWhisperIndex + 360.0f*mfWhisperTimer/(2.0f*(1.1f-fLevel));
					float fPulse2 = (cMath_Sin(cMath_ToRad(fAngle2)) + 1.0f) * 0.5f;
						
					if (mfLevel>WHISPER_AUDIO_OVERWHELM_LEVEL)
					{
						fPulse1=1.0f;
						fPulse2=1.0f;
					}
					
					// Proportions
					float fTotal = fLevel*0.6f + fPulse1*0.2f + fPulse2*0.2f;
					
					// Only start playing sound when the pulses + level get over a certain amount
					fWhisperTarget = cMath_Clamp((fTotal-0.25f)/0.6f,0.0f,1.0f);
					
					if (mfLevel<WHISPER_AUDIO_OVERWHELM_LEVEL)	// To deal with new audio volumes
						fWhisperTarget*=0.25f;
				}
				
				// Boost for hitting a new fear cap.
				fWhisperTarget = cMath_Clamp(fBoost+fWhisperTarget,0.0f,1.0f);
				// Immediately boost, no ramp up.
				if (fBoost>0.0f && fWhisperTarget<fBoost)
				{
					mvWhisperCurrents[mlWhisperIndex] = fBoost;
				}
				
				//if (mlWhisperIndex==0)
				//	cLux_AddDebugMessage("WT:"+fWhisperTarget);
				
				// Approach the level
				if (mvWhisperCurrents[mlWhisperIndex]<fWhisperTarget)
				{
					// Increase slow
					mvWhisperCurrents[mlWhisperIndex] = cMath_IncreaseTo(mvWhisperCurrents[mlWhisperIndex],0.25f*fActualStep,fWhisperTarget);
				}
				else
				{
					// Decrease faster
					float fDecreaseSpeed = mfWhisperDecreaseSpeed <= 0.f ? 0.4f : mfWhisperDecreaseSpeed;
					mvWhisperCurrents[mlWhisperIndex] = cMath_IncreaseTo(mvWhisperCurrents[mlWhisperIndex],fDecreaseSpeed*fActualStep,fWhisperTarget);
				}
				
				if (mvWhisperCurrents[mlWhisperIndex]>0.0f)
				{
					UpdateWhisperPosition(pSound);
				}
				pSound.FadeVolumeMul(mvWhisperCurrents[mlWhisperIndex],10.0f);
			}
		}
		
		if ((mfLevel>WHISPER_AUDIO_OVERWHELM_LEVEL) && mbPermaFail_Enabled && (mFearAreaState==eFearAreaState_Unsafe))
		{
			if (!mbWhisperDuckApplied)
			{
				cSound_FadeGlobalVolume(WHISPER_AUDIO_DUCK_VOLUME, WHISPER_AUDIO_DUCK_VOLUME_FADE, 
					eSoundEntryType_WorldAll, eLuxGlobalVolumeType_Effect,false);
				cSound_FadeGlobalVolume(WHISPER_AUDIO_DUCK_VOLUME, WHISPER_AUDIO_DUCK_VOLUME_FADE, 
					eSoundEntryType_WorldAll, eLuxGlobalVolumeType_Effect,false);
					
				// Only modify music volume outside of permafails to prevent music playing while permafailing. A bit hacky.
				if (mbPermaFail_Active==false && mbPermafail_WakeUpActive == false) 
					cSound_FadeMusicVolumeMul(WHISPER_AUDIO_DUCK_VOLUME, WHISPER_AUDIO_DUCK_VOLUME_FADE);
					
				mbWhisperDuckApplied = true;
			}
		}
		else
		{
			if (mbWhisperDuckApplied)
			{
				cSound_FadeGlobalVolume(1.0f,WHISPER_AUDIO_DUCK_VOLUME_FADE,
					eSoundEntryType_WorldAll, eLuxGlobalVolumeType_Effect,true);
				cSound_FadeGlobalSpeed(1.0f, WHISPER_AUDIO_DUCK_VOLUME_FADE, 
					eSoundEntryType_WorldAll, eLuxGlobalVolumeType_Effect,false);
					
				// Only modify music volume outside of permafails to prevent music playing while permafailing. A bit hacky.
				if (mbPermaFail_Active==false && mbPermafail_WakeUpActive == false) 
					cSound_FadeMusicVolumeMul(1.0f, WHISPER_AUDIO_DUCK_VOLUME_FADE);
					
				mbWhisperDuckApplied = false;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateWhisperPosition(cSoundEntity@ apSound)
	{
		cQuaternion qRotation;
		
		qRotation.FromAngleAxis(
			cMath_ToRad(
			(360.0f/WHISPER_COUNT)*mlWhisperIndex + // Each whisper object has an offset
			(360.0f/WHISPER_ROTATE_DURATION)*mfWhisperTimer), // It takes WHISPER_ROTATE_DURATION to fully circle
			mvWhisperRotations[mlWhisperIndex]);
			
		cMatrixf mtxRotation = cMath_MatrixQuaternion(qRotation);
		
		cCamera@ pCamera = cLux_GetPlayer().GetCamera();
	
		cVector3f origin = pCamera.GetPosition();
		cVector3f offset = pCamera.GetForward();
		offset = cMath_MatrixMul(mtxRotation, offset);
		apSound.SetPosition(origin+offset);
	}
	
	//------------------------------------------------------------

	void OnReceivePlayerBodyMessage(int alMessageId, cLuxEntityMessageData @apData)
	{
		if (mbPermafail_WakeUpActive == false)
			return;

		// Timing of wake up animation effects is controlled by animation events
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			if (apData.mlX == 1) // Veins
			{
				//OnTimer_WakeUp_DoVeins(0);
			}
			else if (apData.mlX == 2) // Stinger sound
			{
				OnTimer_WakeUp_PlayStinger(0);
			}
			else if (apData.mlX == 3) // Stinger effects
			{
				OnTimer_WakeUp_Unblur(0);
				mBaseObj.Timer_Add("OnTimer_WakeUp_Shake", 0.25f, "OnTimer_WakeUp_Shake");
				mBaseObj.Timer_Add("OnTimer_WakeUp_DoProgressionEffects", 1.5f, "OnTimer_WakeUp_DoProgressionEffects");
			}
			else if (apData.mlX == 4) // Change effects
			{		
				//OnTimer_WakeUp_StopVeins(0);
				//mBaseObj.Timer_Add("OnTimer_WakeUp_DoProgressionEffects", 0.75f, "OnTimer_WakeUp_DoProgressionEffects");
			}
		}
	}
	
	//------------------------------------------------------------
	
	//} END OF INTERFACE

	/////////////////////////////////////////
	// MAP LOADING
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnMapEnter(cLuxMap @apMap)
	{
		cLux_AddDebugMessage("[FearHandler] OnMapEnter " + apMap.GetName());
		
		mbInitialized = true;
		
		mbActive = true;
		mbPermaFail_PlayVocals = true;
		SetAverageBrightness(false);
		
		gbCanGasp = true;
				
		mfVfx_DefaultAspect = cLux_GetPlayer().GetCamera().GetAspect();
		mbLevelRegenCapActive = true;

		mlFearAreaMusicState = -1;
		
		mfMaxLevel = 1.0f;
		
		InitFearAreas();
		
		if(gbUseTentacleEffect)
			Effect_FearTentacles_Start();
		else
			Effect_FearTentacles_Stop();
		
		cLux_AddDebugMessage("[FearHandler] ScaryObjects: " + mvScaryObjects.size() + " Threat Objects: " + mvThreats.size() + " Threat Agents: " + mvThreatAgents.size());
	}

	//------------------------------------------------------------

	void OnMapLeave(cLuxMap @apMap)
	{
		cLux_AddDebugMessage("[FearHandler] OnMapLeave " + apMap.GetName());
		
		SetAverageBrightness(false);		
		mbActive = false;
		mbPaused = false;
		mbInitialized = false;
		
		mbDarknessActive = true;
		mfDarknessMaxFactor = gfDarknessMaxFactor;
		mbForceUnderwaterFear = false;
		
		mvForcedFactors.resize(0);
		mvScaryObjects.resize(0);
		mvThreats.resize(0);
		mvThreatAgents.resize(0);
		mvFearObjectRefs.resize(0);
		
		mFearAreaState = eFearAreaState_None;
		
		cLux_SetLookAtCallbacksActive(true);
		cLux_GetPlayer().SetCollideCallbacksActive(true);
		
		/////////////
		// Remove fear areas from previous map
		mActiveFearArea = cFearAreaInfo();
		for (int i = 0; i < int(mvFearAreas.size()); ++i)
		{
			cFearAreaInfo@ pArea = mvFearAreas[i];
			cLux_AddDebugMessage("[FearHandler] Area id: " + pArea.m_idArea + " " + pArea.msMap);
			cLuxArea@ pAreaEnt = cLux_ID_Area(pArea.m_idArea);
			if (pAreaEnt !is null)
			{
				cLux_AddDebugMessage("[FearHandler] Area name: " + pAreaEnt.GetName());
			}
			
			if (pArea.msMap == apMap.GetName())
			{
				mvFearAreas.removeAt(i);
				--i;
				cLux_AddDebugMessage("[FearHandler] Remove: ");
				if (pArea.m_idArea != tID_Invalid && (cLux_ID_Area(pArea.m_idArea) !is null))
				{
					cLux_AddDebugMessage("[FearHandler] Area: " + cLux_ID_Area(pArea.m_idArea).GetName());
				}
			}
		}
		mvInsideFearAreas.resize(0);
		
		/////////////
		// Remove fear rate areas from previous map
		mActiveFearRateArea = cFearRateAreaInfo();
		for (int i = 0; i < int(mvFearRateAreas.size()); ++i)
		{
			cFearRateAreaInfo@ pArea = mvFearRateAreas[i];
			if (pArea.msMap == apMap.GetFileName())
			{
				mvFearRateAreas.removeAt(i);
				--i;
			}
		}
		mvInsideFearRateAreas.resize(0);
		
		mlFearAreaUpdateIndex = 0;
		
		mvPermaFail_Scenes.resize(0);
		SetPermaFailEnabled(false);
		msPermaFail_WakeUpArea="";
		mPermafail_WakeUpMusicPrio = eMusicPrio_SceneAmb;
		mbPermafail_BabyMomentEnabled = false;
		mlPermaFail_PermaFailCount = 0;
		mbPermafail_FastFadeOut = false;
		
		m_idAudio_PermaFailWarning = tID_Invalid;
		m_idAudio_Crackling = tID_Invalid;
		
		mfRate = 0;
		mfDifficultyMul = 1;
		
		for (uint i = 0; i < mvRateMuls.length(); i++)
		{
			mvRateMuls[i].mfValue = 1;
			mvRateMuls[i].mfFadeTime = 0;
		}
		
		Effect_RadialBlur_FadeOut(mlIDRadialBlur, 0.0f);
		
		Effect_ToneMapping_RemoveGradingTexture(gsStruggleGradingTexture);
		mfVfx_StruggleGradingAlpha = 0.f;
		
		SetWhispersActive(false);
		mfWhisperDecreaseSpeed = 0.f;
		
		///////////////////////////
		// Make sure the player won't permafail on map change
		mfLevel = cMath_Min(mfLevel, 0.8f);
		
		//////////////////////
		// Stop emotion sounds
		PlayerEmotion_StopSound(eEmotionPlaylistType_Breathing, m_idAudio_BreathingLoop);
		m_idAudio_BreathingLoop = -1;
		PlayerEmotion_StopSound(eEmotionPlaylistType_Breathing, m_idAudio_FearSystemLoop);
		m_idAudio_FearSystemLoop = -1;
	}
	
	//------------------------------------------------------------
	
	void PreloadData(cLuxMap @apMap)
	{
		apMap.PreloadMaterial("baby_reduce_fear_screen.mat");
		Effect_FearTentacles_PreloadData(apMap);
		
		for (uint i = 0; i < gvPermafailBabyEnts.length(); i++)
			apMap.PreloadEntity(gvPermafailBabyEnts[i]);
	}
	
	//------------------------------------------------------------

	void CreateWorldEntities(cLuxMap @apMap)
	{
	
	}
	
	//------------------------------------------------------------
	
	void DestroyWorldEntities(cLuxMap @apMap)
	{
		for (uint i = 0; i < gvPermafailBabyEnts.length(); i++)
		{
			if (Entity_Exists(gvPermafailBabyEnts[i]))
				Entity_Destroy(gvPermafailBabyEnts[i]);
		}
	}
	
	//------------------------------------------------------------
	
	//} END OF MAP LOADING

	/////////////////////////////////////////
	// GENERAL
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnEnterContainer(const tString&in asOldContainer)
	{
	
	}
	
	//------------------------------------------------------------
	
	void OnLeaveContainer(const tString&in asNewContainer)
	{
	
	}

	//------------------------------------------------------------
	
	void VariableUpdate(float afTimeStep)
	{
		if (mbActive || mbPermaFail_Active)
			UpdatePermaFail(afTimeStep);
			
		if (mbActive == false) return;
				
		/////////////////////////////
		// Updates
		UpdateFearAreas(afTimeStep);
		UpdateFearRateAreas(afTimeStep);
		UpdateFearObjects(afTimeStep);
		UpdateVisualEffects(afTimeStep);
		UpdateAudio(afTimeStep);
		UpdateFearAdditions(afTimeStep);
		UpdateFocus(afTimeStep);
		UpdateLevelRegenCap(afTimeStep);
		UpdateHints(afTimeStep);
		UpdatePlayerInfo(afTimeStep);
		
		// TODO: Uncomment. This is in Update() for now, since screen effects don't play nice when started in VariableUpdate
		//UpdateBabyKicks(afTimeStep);
		
		if (mbPaused) return;
		
		/////////////////////////////
		// Update rate with fear factors
		mfRate = 0.0f;
		mfRate += GetDarknessFactor(afTimeStep);
		mfRate += mfScaryObjectFactor;
		mfRate += mfThreatFactor;
		mfRate += GetFearRateAreaFactor(afTimeStep);
		mfRate = cMath_Clamp(mfRate, 0.0f, (mActiveFearArea.m_idArea != tID_Invalid) ? mActiveFearArea.mfNonAgentRateCap : 1.0f); // cap non-agent rate
		mfRate += GetForcedFactor(afTimeStep);
		mfRate += mfThreatAgentFactor;
		mfRate += GetPeaceFactor(afTimeStep);
            
		mfRate = cMath_Clamp(mfRate, -1.0f, 1.0f);
		
		for (uint i = 0; i < mvRateMuls.length(); i++)
		{
			cFearRateMul@ pMul = mvRateMuls[i];
			float fMulFadeSpeed = pMul.mfFadeTime > 0 ? (1.0f / pMul.mfFadeTime) : 0.0f;
			pMul.mfValue = cMath_IncreaseTo(pMul.mfValue, fMulFadeSpeed * afTimeStep, pMul.mfTarget);
			if (mfRate > 0) mfRate *= pMul.mfValue;
		}

		if (mbLevelFade_Active) return;
		
		/////////////////////////////
		// Update fear level
		float fLevelRate = mfRate >= 0.0f ? (1.0f / 100.0f) : (1.0f / 10.0f);
		fLevelRate *= mfFearLevelRateMul;
		if (mfRate >= 0.0f && mfRate < mfRateMin) fLevelRate = 0.0f; // only fear rate over mfRateMin will affect level
		mfLevel += fLevelRate * mfRate * mfDifficultyMul * afTimeStep;
		mfLevel = cMath_Clamp(mfLevel, GetCurrentLevelRegenCap(), mfMaxLevel);
		
		if (cLux_GetGodModeActivated())
		{
			mfLevel = 0.0f;
			mfRate = 0.0f;
			mlLevelRegenStep = 0;
		}
	}
	
	//------------------------------------------------------------
	
	bool mbNightVisionActive = false;
	float mfNightVisionRadiusMax = 0;
	float mfNightVisionBrightness = 0;
	void UpdatePlayerInfo(float afTimeStep)
	{
		mbNightVisionActive = mActiveFearArea.mbDarknessFear && Player_IsNightVisionActive();
		mfNightVisionRadiusMax = Player_GetNightVisionRadiusMax();
		mfNightVisionBrightness = Player_GetNightVisionBrightness();
	}
	
	//------------------------------------------------------------
	
	int mlFearAreaUpdateIndex = 0;
	array<cFearAreaInfo> mvFearAreas;
		
	void InitFearAreas()
	{
	}
	
	void UpdateFearAreas(float afTimeStep)
	{
		if (mvFearAreas.size() == 0) return;
		cFearAreaInfo@ pAreaInfo = mvFearAreas[mlFearAreaUpdateIndex];
		
		cLuxArea@ pArea = cLux_ID_Area(pAreaInfo.m_idArea);
		if (pArea is null)
		{
			UpdateFearAreaIndex(); // TODO: skips null areas for now, but there shouldn't be any in the first place
			return;
		}
				
		cLuxArea@ pActiveArea = cLux_ID_Area(mActiveFearArea.m_idArea);
		if (pActiveArea !is null)
		{
//			if (pActiveArea.IsActive() == false) mActiveFearArea.m_idArea = tID_Invalid;
		}
		
		bool bCollides = pArea.CollidesWithPlayer() && pArea.IsActive();
		if (pAreaInfo.mbCollidesWithPlayer == false && bCollides)
		{
			pAreaInfo.mbProgressInside = false;
			mvInsideFearAreas.push_back(pAreaInfo);
			if (mActiveFearArea.m_idArea == tID_Invalid ||
				pAreaInfo.mlPriority > mActiveFearArea.mlPriority ||
				(pAreaInfo.mlPriority == mActiveFearArea.mlPriority && (pAreaInfo.mbSafe == false || pAreaInfo.mbSafe && mActiveFearArea.mbSafe)))
			{
				mActiveFearArea = pAreaInfo;
				UpdateFearAreaState();
			}	
		}
		else if (pAreaInfo.mbCollidesWithPlayer && (bCollides == false || pArea.IsActive() == false))
		{
			for (uint i = 0; i < mvInsideFearAreas.size(); ++i)
			{
				cFearAreaInfo@ pInsideArea = mvInsideFearAreas[i];
				if (pInsideArea.m_idArea != pAreaInfo.m_idArea) continue;
				
				mvInsideFearAreas.removeAt(i);
				if (mActiveFearArea.m_idArea != tID_Invalid && mActiveFearArea.m_idArea == pAreaInfo.m_idArea)
				{
					mActiveFearArea.m_idArea = tID_Invalid;
					if (mvInsideFearAreas.size() > 0)
					{
						mvInsideFearAreas.sortDesc();
						mActiveFearArea = mvInsideFearAreas[0];
					}
					UpdateFearAreaState();
				}
				break;
			}
		}
		
		if (bCollides) TryProgress(pAreaInfo);
		
		pAreaInfo.mbCollidesWithPlayer = bCollides;
		UpdateFearAreaIndex();
	}
	
	void UpdateFearAreaIndex()
	{
		++mlFearAreaUpdateIndex;
		mlFearAreaUpdateIndex %= mvFearAreas.size();
	}
	
	void TryProgress(cFearAreaInfo@ pAreaInfo)
	{
		if (pAreaInfo.mbProgressInside) return;
		if (pAreaInfo.mbSafe == false) return;
		if (IsSituationSafe() == false) return;
		bool bProgress = (pAreaInfo.mbAllowProgressWithToken && mbProgressToken) || (pAreaInfo.mbAllowProgressWithoutToken && pAreaInfo.mlProgressCounter < pAreaInfo.mlMaxProgressCount);
		if (bProgress == false) return;
		
		mlLevelRegenStep = cMath_Clamp(mlLevelRegenStep - pAreaInfo.mlProgressAmount, 0, mvLevelRegenSteps.size());
		pAreaInfo.mbProgressInside = true;
		++pAreaInfo.mlProgressCounter;
		mlPermaFail_StruggleCount = 0;
		mlPermaFail_PermaFailCount = 0;
		if (pAreaInfo.mbAllowProgressWithToken) mbProgressToken = false;
		
		return;
	}
	
	//------------------------------------------------------------
	
	int mlFearRateAreaUpdateIndex = 0;
	array<cFearRateAreaInfo> mvFearRateAreas;
	array<cFearRateAreaInfo> mvInsideFearRateAreas;
	cFearRateAreaInfo mActiveFearRateArea;
	
	void UpdateFearRateAreas(float afTimeStep)
	{
		if (mvFearRateAreas.size() == 0) return;
		++mlFearRateAreaUpdateIndex;
		mlFearRateAreaUpdateIndex %= mvFearRateAreas.size();
		
		cFearRateAreaInfo@ pAreaInfo = mvFearRateAreas[mlFearRateAreaUpdateIndex];
		
		cLuxArea@ pArea = cLux_ID_Area(pAreaInfo.m_idArea);
		if (pArea is null) return;
		
		cLuxArea@ pActiveArea = cLux_ID_Area(mActiveFearRateArea.m_idArea);
		if (pActiveArea !is null)
		{
			if (pActiveArea.IsActive() == false) mActiveFearRateArea.m_idArea = tID_Invalid;
		}
		
		bool bCollides = pArea.CollidesWithPlayer() && pArea.IsActive();
		if (pAreaInfo.mbCollidesWithPlayer == false && bCollides)
		{
			mvInsideFearRateAreas.push_back(pAreaInfo);
			if (mActiveFearRateArea.m_idArea == tID_Invalid ||
				pAreaInfo.opCmp(mActiveFearRateArea) >= 0)
			{
				mActiveFearRateArea = pAreaInfo;
			}
		}
		else if (pAreaInfo.mbCollidesWithPlayer && bCollides == false)
		{
			for (uint i = 0; i < mvInsideFearRateAreas.size(); ++i)
			{
				cFearRateAreaInfo@ pInsideArea = mvInsideFearRateAreas[i];
				if (pInsideArea.m_idArea != pAreaInfo.m_idArea) continue;
				
				mvInsideFearRateAreas.removeAt(i);
				
				if (mActiveFearRateArea.m_idArea != tID_Invalid && mActiveFearRateArea.m_idArea == pInsideArea.m_idArea)
				{
					mActiveFearRateArea.m_idArea = tID_Invalid;
					if (mvInsideFearRateAreas.size() > 0)
					{
						mvInsideFearRateAreas.sortDesc();
						mActiveFearRateArea = mvInsideFearRateAreas[0];
					}
				}
			}
		}
		
		pAreaInfo.mbCollidesWithPlayer = bCollides;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	float mfDarknessMaxFactor = gfDarknessMaxFactor;
	float mfDarknessIncreaseTime = 3.0f;
	float mfDarknessDecreaseTime = 3.0f;
	float mfDarknessSafeAreaDecreaseTime = 3.0f;
	float mfDarknessDelay = 0.0f;
	
	float mfDarknessDelayTimer = 0.0f;
	float mfDarknessFactor = 0.0f;
	float mfDarknessLastIncreaseFactor = 0.0f;
	bool mbDarknessPeace = false;
	bool mbUnderwaterFear = false;
	bool mbForceUnderwaterFear = false;
	
	float mfDebugDarknessFactorTarget = 0.0f;
		
	float GetDarknessFactor(float afTimeStep)
	{				
		// Don't count the lantern as peace env
		bool bLightSourceActive = Item_IsLightSourceActive();
		float fDeepShadow = Player_GetMapDeepShadow();
		float fLightLevel = Player_GetLightLevel(true, true);
		
		mbDarknessPeace = fLightLevel >= fDeepShadow || bLightSourceActive;
		bool bSafeArea = GetFactors(false, true, true, true, true, true, false) <= 0.0f && mbDarknessPeace;
		bool bForcedUnderwaterFear = mbForceUnderwaterFear && Player_GetUnderwater();
		
		float fFactorTarget = 0.0f;
		
		// don't add darkness factor if the area doesn't allow it
		bool bDarknessArea = true;
		if (mActiveFearArea.m_idArea != tID_Invalid && mActiveFearArea.mbDarknessFear == false) bDarknessArea = false;
		
		if (mFearAreaState == eFearAreaState_Unsafe && (bDarknessArea || bForcedUnderwaterFear) && mbDarknessActive /* && Player_GetUnderwater() == false */)
		{
			if ((fLightLevel < fDeepShadow && bLightSourceActive == false) || bForcedUnderwaterFear) fFactorTarget += mfDarknessMaxFactor;
//			fFactorTarget *= 1.0f - (cMath_Clamp(mfLevel - 0.5f, 0.0f, 0.5f) / 0.5f);
		}
		
		if (fFactorTarget > 0.0f)
		{
			mfDarknessDelayTimer += afTimeStep;
			if (mfDarknessDelayTimer < mfDarknessDelay) fFactorTarget = 0.0f;
			
			////////////////////////////
			// Set crackling level
			mfCracklingLevel = cMath_Max(mfLevel, mfCracklingLevel);
		}
		else
		{
			mfDarknessDelayTimer = 0.0f;
		}
		
		bool bIncrease = fFactorTarget >= mfDarknessFactor;
		float fChangeSpeed = 0.0f;
		if (bIncrease) fChangeSpeed = 1.0f / mfDarknessIncreaseTime;
		else if (bSafeArea) fChangeSpeed = 1.0f / mfDarknessSafeAreaDecreaseTime;
		else if (bSafeArea == false) fChangeSpeed = 1.0f / mfDarknessDecreaseTime;
		mfDarknessFactor = cMath_IncreaseTo(mfDarknessFactor, fChangeSpeed * afTimeStep, fFactorTarget);
		
		mfDebugDarknessFactorTarget = fFactorTarget;
				
		return mfDarknessFactor;
	}
		
	//------------------------------------------------------------
	
	float mfScaryObjectFactor = 0.0f;
	float mfThreatFactor = 0.0f;
	float mfThreatAgentFactor = 0.0f;
	array<float> mvFearObjectFalloff = { 1.0f, 0.8f, 0.6f, 0.4f, 0.2f };
	array<int> mvUpdateObjects;
	
	float mfFearObject_UpdateInterval = 0.21f;
	
	int mlFearObject_UpdateStepIndex = 0;
	int mlFearObject_ObjectIndex = 0;
	int mlFearObject_IntervalUpdateCount;
	int mlFearObject_GuaranteedPerFrame;
	int mlFearObject_RemainingPerFrame;
	int mlFearObject_InitCount = -1;
	
	void InitFearObjectUpdateInterval()
	{
		mlFearObject_UpdateStepIndex = 0;
		mlFearObject_ObjectIndex = 0;
		mlFearObject_IntervalUpdateCount = cMath_FloorToInt(mfFearObject_UpdateInterval / cEngine_GetStepSize());
		mlFearObject_GuaranteedPerFrame = cMath_FloorToInt(GetFearObjectCount() / mlFearObject_IntervalUpdateCount);
		mlFearObject_RemainingPerFrame = GetFearObjectCount() - (mlFearObject_IntervalUpdateCount * mlFearObject_GuaranteedPerFrame);
		mlFearObject_InitCount = GetFearObjectCount();
	}
	
	void UpdateFearObjects(float afTimeStep)
	{
		if (GetFearObjectCount() != mlFearObject_InitCount) InitFearObjectUpdateInterval();
		
		mvUpdateObjects.resize(0);
		int lObjectsToUpdate = mlFearObject_GuaranteedPerFrame;
		if (mlFearObject_UpdateStepIndex < mlFearObject_RemainingPerFrame) ++lObjectsToUpdate;
		for (int i = 0; i < lObjectsToUpdate; ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[mlFearObject_ObjectIndex];
			
			pFearObject.mlIndex = mlFearObject_ObjectIndex;
			mvUpdateObjects.push_back(mlFearObject_ObjectIndex);
			
			pFearObject.PeriodicUpdate(this);
			++mlFearObject_ObjectIndex;
		}
		
		++mlFearObject_UpdateStepIndex;
		if (mlFearObject_UpdateStepIndex >= mlFearObject_IntervalUpdateCount)
		{
			mlFearObject_UpdateStepIndex = 0;
			mlFearObject_ObjectIndex = 0;
		}
		
		mfScaryObjectFactor = 0.0f;
		mfThreatFactor = 0.0f;
		mfThreatAgentFactor = 0.0f;		
		mvActiveFearObjects.resize(0);
		
		if (mFearAreaState == eFearAreaState_None)
		{
			mfScaryEntityInViewFearRate = 0;
			mbIsLookingAtScaryEntity = false;
			return;
		}
		
		for (int i = 0; i < GetFearObjectCount(); ++i)
		{
			cFearObject@ pFearObject = GetFearObjects()[i];
			pFearObject.Update(afTimeStep);
			
			if (pFearObject.mfFearRate > 0.0f)
			{
				mfScaryEntityInViewFearRate = pFearObject.IsSeen() && pFearObject.mbFearActive && GetIsPermaFailing()==false?pFearObject.mfFearRate:0.f;
				mbIsLookingAtScaryEntity = pFearObject.IsSeen() && pFearObject.mbFearActive && GetIsPermaFailing()==false?true:false;
				mvActiveFearObjects.push_back(pFearObject);
			}
		}
		
		mvActiveFearObjects.sortDesc();
		
		// only allow one threat agent to add fear
		int lAgents = 0;
		for (int i = 0; i < int(mvActiveFearObjects.size()); ++i)
		{
			cFearObject@ pFearObject = mvActiveFearObjects[i];
			if (pFearObject.mType != eFearObject_ThreatAgent) continue;
			++lAgents;
			if (lAgents > 1)
			{
				mvActiveFearObjects.removeAt(i);
				--i;
			}
		}
		
		if (mvActiveFearObjects.size() > mvFearObjectFalloff.size()) mvActiveFearObjects.resize(mvFearObjectFalloff.size());
		for (uint i = 0; i < mvActiveFearObjects.size(); ++i)
		{
			cFearObject@ pFearObject = mvActiveFearObjects[i];
						
			switch(pFearObject.mType)
			{
				case eFearObject_ScaryObject:
					if (mFearAreaState != eFearAreaState_Unsafe) break;
					pFearObject.mfFalloffMul = mvFearObjectFalloff[i];
					mfScaryObjectFactor += pFearObject.mfFearRate;
					break;
					
				case eFearObject_Threat:
					if (mFearAreaState != eFearAreaState_Unsafe) break;
					mfThreatFactor += pFearObject.mfFearRate;
					break;
					
				case eFearObject_ThreatAgent:
					mfThreatAgentFactor += pFearObject.mfFearRate;
					break;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnLineOfSight_FearObject(bool abSuccesful, int alUservalue)
	{
		if (GetFearObjects().size() <= uint(alUservalue)) return;
		
		cFearObject@ pFearObject = GetFearObjects()[alUservalue];
		pFearObject.OnLineOfSight_Update(abSuccesful);
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	float mfFearRateAreaIncreaseSpeed = 0.2f;
	float mfFearRateAreaDecreaseSpeed = 0.2f;
	float mfFearRateAreaCurrentIncreaseSpeed = -1.0f;
	float mfFearRateAreaCurrentDecreaseSpeed = -1.0f;
	
	float mfFearRateAreaFactor = 0.0f;
	
	float GetFearRateAreaFactor(float afTimeStep)
	{
		float fFactorTarget = 0.0f;
		
		if (mActiveFearRateArea.m_idArea != tID_Invalid)
		{
			fFactorTarget = mActiveFearRateArea.mfFearRate;
		}
		
		float fIncreaseSpeed = mfFearRateAreaCurrentIncreaseSpeed < 0.0f ? mfFearRateAreaIncreaseSpeed : mfFearRateAreaCurrentIncreaseSpeed;
		float fDecreaseSpeed = mfFearRateAreaCurrentDecreaseSpeed < 0.0f ? mfFearRateAreaDecreaseSpeed : mfFearRateAreaCurrentDecreaseSpeed;
		bool bIncrease = fFactorTarget >= mfFearRateAreaFactor;
		float fChangeSpeed = bIncrease ? fIncreaseSpeed : fDecreaseSpeed;
		mfFearRateAreaFactor = cMath_IncreaseTo(mfFearRateAreaFactor, fChangeSpeed * afTimeStep, fFactorTarget);
		return mfFearRateAreaFactor;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	float mfForcedIncreaseSpeed = 0.25f;
	float mfForcedDecreaseSpeed = 0.25f;
	float mfForcedFactor = 0.0f;
	array<cFearForcedFactor> mvForcedFactors;
    bool mbFearFromHeat = false;
	
	float GetForcedFactor(float afTimeStep)
	{
		mfForcedFactor = 0.0f;		
		for (uint i = 0; i < mvForcedFactors.size(); i++)
		{
			cFearForcedFactor@ factor = mvForcedFactors[i];
			
			float fFactorTarget = 0.0f;
			if (mFearAreaState != eFearAreaState_None && factor.mfForcedFactorDurationTimer <= factor.mfForcedFactorDuration && factor.mfForcedFactorDuration != 0)
			{
				fFactorTarget = factor.mfForcedFactorTarget;
				if (gbCanGasp && factor.mbForcedDoGasp)
				{
					factor.mbForcedDoGasp = false;
					PlayGasp(0.0f, factor.mfForcedFactorTarget, true);
				}
			}
			
			
            mbFearFromHeat = fFactorTarget > 0.f && i == eFearForcedRateType_Heat;
			if (mbFearFromHeat)
				mfCracklingLevel = cMath_Max(mfCracklingLevel, 0.5f);
			
			//cLux_AddDebugMessage("mbFearFromHeat:"+mbFearFromHeat+" Target: "+fFactorTarget);
			
			if (factor.mfForcedFactorDurationTimer > 0.0f)
			{
				factor.mfForcedFactorDurationTimer -= afTimeStep;
				if (factor.mfForcedFactorDurationTimer <= 0.0f)
				{
					factor.mfForcedFactorTarget = 0.0f;
					factor.mfForcedFactorDurationTimer = -1.0f;
				}
			}
			
			bool bIncrease = fFactorTarget >= factor.mfForcedFactor;
			float fIncreaseTime = factor.mfForcedIncreaseSpeedUserValue >= 0.0f ? factor.mfForcedIncreaseSpeedUserValue : 
																				  mfForcedIncreaseSpeed;
			float fDecreaseTime = factor.mfForcedDecreaseSpeedUserValue >= 0.0f ? factor.mfForcedDecreaseSpeedUserValue : 
																				  mfForcedDecreaseSpeed;
			float fChangeSpeed = bIncrease ? fIncreaseTime : fDecreaseTime;
			factor.mfForcedFactor = cMath_IncreaseTo(factor.mfForcedFactor, fChangeSpeed * afTimeStep, fFactorTarget);
			
			mfForcedFactor += factor.mfForcedFactor;
		}
		
		if (mfForcedFactor > 1.f)
			mfForcedFactor = 1.f;
		
		return mfForcedFactor;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	float mfPeaceIncreaseTime = 2.0f;
	float mfPeaceDecreaseTime = 2.0f;
	float mfPeaceTime = 0.5f;
	float mfPeaceRateScary = -1.0f;
	float mfPeaceRateNoScary = -1.0f;
	float mfPeaceTriggerLevel = 0.0f;
	
	float mfPeaceFactor = 0.0f;
	float mfPeaceFactorTarget = 0.0f;
	float mfPeaceTimer = 0.0f;
	
	float GetPeaceFactor(float afTimeStep)
	{
		if (mbBabyKickPeace)
		{
			if (mfLevel > mfLevelAfterBabyKick)
				mfPeaceFactorTarget = mfPeaceRateScary;
			else
				mbBabyKickPeace = false;
		}
		else if (Pregnancy_GetBabyKicksEnabled() == false && IsSituationSafe() && 
				 mbDarknessPeace && mfLevel > GetCurrentLevelRegenCap())
		{
			mfPeaceTimer += afTimeStep;
			if (mfPeaceTimer > mfPeaceTime)
			{
				mfPeaceFactorTarget = mfPeaceRateScary;
			}
		}
		else
		{
			mfPeaceTimer = 0.0f;
			mfPeaceFactorTarget = 0.0f;
		}

		bool bIncrease = mfPeaceFactorTarget >= mfPeaceFactor;
		float fChangeSpeed = bIncrease ? (1.0f / mfPeaceIncreaseTime) : (1.0f / mfPeaceDecreaseTime);
		mfPeaceFactor = cMath_IncreaseTo(mfPeaceFactor, fChangeSpeed * afTimeStep, mfPeaceFactorTarget);

		return mfPeaceFactor;
	}

	//------------------------------------------------------------
	
	bool mbHint_AllowWarning = false;
	float mfHint_WarningCount = 0.f;	
	bool mbHint_AllowDarknessReminder = false;
	float mfHint_DarknessCount = 0.f;	
	bool mbHint_AllowLanternReminder = false;
	float mfHint_LanternReminderCount = 0.f;
	bool mbHint_AllowLanternOveruse = false;
	float mfHint_LanternOveruseCount = 0.f;
	bool mbHint_AllowRefillLantern = false;
	float mfHint_RefillLanternCount = 0.f;
	bool mbHint_AllowMonsterHint = true;
	float mfHint_MonsterCount = 0.f;
	
	void UpdateHints(float afTimeStep)
	{
		///////////////////
		// Setup vars
		bool bInDarkness = mfRate >= 0.2f && mbDarknessPeace == false;
		
		///////////////////
		// Darkness
		if (mbHint_AllowWarning && mBaseObj.Timer_Exists(0) == false)
		{
			if (bInDarkness)
			{
				mfHint_WarningCount += afTimeStep;
				if (mfHint_WarningCount >= 3.f)
				{		
					// DISABLED REMINDER HINT
					//Hint_ShowHint("Hints", "HintFearDarkness", false, 1.5f, false);
					ResetRepeatingHints(0);
				}
			}
			else
			{
				mfHint_WarningCount = 0.0f;
			}
		}
		
		///////////////////
		// Refill lantern
		if (mbHint_AllowRefillLantern && mBaseObj.Timer_Exists(1) == false)
		{
			bool bGotOil = Oil_GetCount() > 0;
			bool bLanternGotOil = Item_GetContentLevel(ItemType_GetFirstInInventory("Lantern")) > 0;			
			
			if (bInDarkness && bGotOil && bLanternGotOil == false)
			{
				mfHint_RefillLanternCount += afTimeStep;
				if (mfHint_RefillLanternCount >= 3.f)
				{
					Hint_RemoveFromGiven("Hints", "HintOil");
					
					// DISABLED REMINDER HINT
					//Hint_ShowHint("Hints", "HintOil", false, 1.5f, false);
					
					ResetRepeatingHints(1);
				}
			}
			else
			{
				mfHint_RefillLanternCount = 0.f;
			}
		}
		
		///////////////////
		// Darkness reminder
		if (mbHint_AllowDarknessReminder)
		{
			if (mfLevel >= 0.85f && mbDarknessPeace == false && bInDarkness)
			{
				mfHint_DarknessCount += afTimeStep;
				if (mfHint_DarknessCount >= 5.f)
				{
					mbHint_AllowDarknessReminder = false;
					// DISABLED REMINDER HINT
					//Hint_ShowHint("Hints", "HintDarknessReminder", false);
				}
			}
			else
			{
				mfHint_DarknessCount = 0.f;
			}
		}
		
		///////////////////
		// Lantern reminder
		if (mbHint_AllowLanternReminder)
		{
			if (bInDarkness)
			{
				if (Hint_IsShowing() == false)
					mfHint_LanternReminderCount += afTimeStep;
				
				if (mfHint_LanternReminderCount >= 10.f && 
					Item_GetContentLevel(ItemType_GetFirstInInventory("Lantern")) > 0)
				{
					mbHint_AllowLanternReminder = false;					
					Hint_RemoveFromGiven("Hints", "HintFlashlight");
					
					// DISABLED REMINDER HINT
					//Hint_ShowHint("Hints", "HintFlashlight", true);				
				}
			}
			else
			{
				mfHint_LanternReminderCount = 0.f;
			}
		}
		
		///////////////////
		// Lantern overuse
		if (mbHint_AllowLanternOveruse)
		{
			if (bInDarkness && Item_GetHeldType(eItemHandlerHand_Left) == "Lantern")
			{
				if (Hint_IsShowing() == false)
					mfHint_LanternOveruseCount += afTimeStep;
				
				if (mfHint_LanternOveruseCount >= 20.f)
				{
					mbHint_AllowLanternOveruse = false;
					
					// DISABLED REMINDER HINT
					//Hint_ShowHint("Hints", "HintLanternOveruse", true);
				}
			}
			else
			{
				mfHint_LanternOveruseCount = 0.f;
			}
		}
		
		///////////////////
		// Monsters
		if (mbHint_AllowMonsterHint)
		{
			if (GetFactors(false, false, false, false, false, true, false) > 0.f && Blackboard_GetAgentCount() > 0)
			{ 
				mfHint_MonsterCount += afTimeStep;
				if (mfHint_MonsterCount >= 2.f)
				{
					if (Hint_IsShowing())
					{
						mfHint_MonsterCount = 0.f;
					}
					else
					{
						mbHint_AllowMonsterHint = false;
						Hint_ShowHint("Hints", "HintMonsterFear", false);
					}
				}
			}
			else
			{
				mfHint_MonsterCount = 0.f;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void ResetRepeatingHints(int alId)
	{
		/////////////////////
		// Don't allow hint for next 30 min
		mBaseObj.Timer_Add(alId, 60.f * 30.f, ""); 
		
		/////////////////////
		// Make sure other repeating hint is at least 5 min away
		int lOtherHintId = alId == 1 ? 0 : 1;
		if (mBaseObj.Timer_GetTimeLeft(lOtherHintId) < 60.f * 5.f)
		{
			mBaseObj.Timer_Remove(lOtherHintId);
			mBaseObj.Timer_Add(lOtherHintId, 60.f * 5.f, "");
		}
	}
	
	//------------------------------------------------------------
	
	void SetAllowLanternReminderHint(bool abX)
	{
		mbHint_AllowLanternReminder = abX;
	}
	
	//------------------------------------------------------------
	
	void SetAllowLanternOveruseHint(bool abX)
	{
		mbHint_AllowLanternOveruse = abX;
	}
	
	//------------------------------------------------------------
	
	void SetAllowLanternRefillHint(bool abX)
	{
		mbHint_AllowRefillLantern = abX;
	}
	
	//------------------------------------------------------------
	
	void SetAllowWarningHint(bool abX)
	{
		mbHint_AllowWarning = abX;
	}
	
	//------------------------------------------------------------
	
	void SetAllowDarknessReminderHint(bool abX)
	{
		mbHint_AllowDarknessReminder = abX;
	}
	
	//------------------------------------------------------------
	
	void SetAllowMonsterHint(bool abX)
	{
		mbHint_AllowMonsterHint = abX;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	int mlBabyKickId = -1;
	bool mbBabyKickPeace = false;
	bool mbBabyKickPeaceEffectsActive = false;
	float mfLevelAfterBabyKick = 1.f;
	float mfLevelReductionAfterBabyKick = 0.f;
	float mfResetFearMulRateCount = -1.f;
	
	bool mbKickTimersReset = false;
	float mfNextKickThreshold = 35.f;
	float mfNextKickDelay = 4.f;
	
	void UpdateBabyKicks(float afTimeStep)
	{		
		/////////////////////////
		// Setup vars
		iScrPregHandler_Interface@ pPregnancy = cast<iScrPregHandler_Interface>(cLux_GetUserModuleFromID(eModuleType_Custom_PregHandler));
		bool bKicksEnabled = pPregnancy.GetBabyKicksEnabled();
		int lKickId = pPregnancy.GetBabyKickId();
		
        /////////////////////////
        // Safe room baby kicks
		if (bKicksEnabled)
		{
			//cLux_AddDebugMessage("Kicks Enabled!");
			if (IsSituationSafe())
			{
				//cLux_AddDebugMessage("Safe!");
				mfTimeSinceSafeRoomEnter += afTimeStep;
				
				// Countdown
				if (mbSafeRoomBabyKickDone==false)
				{
					if (mbKickTimersReset==false)
					{
						float fSafeAreaBabyKickDelayMul = 1/mActiveFearArea.mfBabyKickRateMultiplier;
						mfNextKickThreshold = cMath_RandRectf(30.f, 45.f) * fSafeAreaBabyKickDelayMul;
						mfNextKickDelay = cMath_RandRectf(4.f, 8.f);
						mbKickTimersReset = true;
					}
					
					bool bStayedAwayFromSafeArea = mfTimeSincePostKickSafeRoomExit >= mfNextKickThreshold;
					float fBabyKickDelay = bStayedAwayFromSafeArea ? mfNextKickDelay : mfNextKickThreshold;
					
					// Do kick
					if (mfTimeSinceSafeRoomEnter >= fBabyKickDelay)
					{
						pPregnancy.DoBabyKick(true);
						
						mfTimeSincePostKickSafeRoomExit = 0.f;
						mbSafeRoomBabyKickDone = true;
					}
				}
			}
			else // When the room is not safe or baby can't kick
			{
				//cLux_AddDebugMessage("NOT Safe!");
				mfTimeSincePostKickSafeRoomExit+=afTimeStep;
				
				mbKickTimersReset = false;
				
				if (mfTimeSinceSafeRoomEnter > 0.f)
					mfTimeSinceSafeRoomEnter = 0.f;
				
				//if (mbSafeRoomBabyKickDone)
					mbSafeRoomBabyKickDone = false;
			}
		}
		
		/////////////////////////
		// Reduce fear?
		bool bStateOK = Player_IsTalkingToBaby();
		bool bPeaceOK = mbBabyKickPeace == false && mbBabyKickPeaceEffectsActive == false;
		bool bKicksOK = bKicksEnabled && 
						mlBabyKickId != lKickId &&
						Effect_BabyKick_IsActive() == false &&
						pPregnancy.GetTimeSinceLastBabyKick() < gfBabyKickFearReductionTime;
		
		if (bStateOK && bPeaceOK && bKicksOK)
		{			
			mlBabyKickId = lKickId;
			mfLevelAfterBabyKick = mFearAreaState == eFearAreaState_Safe ? 0.f : mfLevel - 0.15f;
			mfLevelAfterBabyKick = cMath_Clamp(mfLevelAfterBabyKick, GetCurrentLevelRegenCap(), 1.f);
			mfLevelReductionAfterBabyKick = mfLevel - mfLevelAfterBabyKick;
			
			if (mfLevelReductionAfterBabyKick > 0.f)
				mbBabyKickPeace = true;
		}
		
		/////////////////////////
		// Show hint if player has missed 2 kicks in a row
		if (pPregnancy.GetTimeSinceLastBabyKick() < gfBabyKickFearReductionTime && 
			mlBabyKickId <= lKickId - 2 && lKickId % 3 == 0)
		{
			Hint_ShowHint("Hints", "HintBabyKickFear", false, 1.5f, false);
		}
		
		/////////////////////////
		// Reduction effects
		if (mbBabyKickPeace)
		{
			if (mbBabyKickPeaceEffectsActive == false)
			{
				mbBabyKickPeaceEffectsActive = true;
				
				FadeRateMulTo(eFearRateMulType_BabyKick, 0.f, 2.f);
				Effect_FearTentacles_FadeMul(0.75, 4.f);
				
				//float fAspect =  cLux_GetPlayer().GetCamera().GetAspect();
				//float fBaseSize = 0.945f - (0.383f * (fAspect - 1.333f));
				//cVector2f vSize = cVector2f(fBaseSize * fAspect, fBaseSize);
				cVector2f vSize = cVector2f(1.25, 1);
				Effect_Screen_Start("baby_reduce_fear_screen.mat", cVector2f(0.5f, 0.5f), vSize, 0.2f, 1.f, 3.f, 2.f, -10);
			}
		}
		else 
		{
			if (mbBabyKickPeaceEffectsActive)
			{
				mbBabyKickPeaceEffectsActive = false;
				mfResetFearMulRateCount = 8.f;
				Effect_FearTentacles_FadeMul(1.f, mfResetFearMulRateCount);				
			}
			
			if (mfResetFearMulRateCount > 0.f)
			{
				mfResetFearMulRateCount -= afTimeStep;
				if (mfResetFearMulRateCount <= 0.f)
					FadeRateMulTo(eFearRateMulType_BabyKick, 1.f, 5.f);
			}		
		}
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	cVector2f mvVfx_FovPulseTime = cVector2f(0.3f, 0.4f);
	cVector2f mvVfx_PulseFovRange = cVector2f(0.04f, 0.06f);
	cVector2f mvVfx_PulseAspectRange = cVector2f(0.06f, 0.10f);
	cVector2f mvVfx_PulseRollRange = cVector2f(1.0f, 3.0f);
	float mfVfx_PulseOutPause = 0.00f;	
	float mfVfx_DefaultAspect = 0.0f;
	float mfVfx_Pulse = 0.0f;
	float mfVfx_PulseT = 0.0f;
	float mfVfx_FovPulseTime = 0.0f;
	float mfVfx_FovPulseTarget = 0.0f;
	float mfVfx_AspectTarget = 0.0f;
	float mfVfx_RollTarget = 0.0f;
	float mfVfx_ForcePulseOutCount = 0.f;
	bool mbVfx_PulseIn = false;
	float mfVfx_PulseOutPauseTimer = 0.0f;	
	[nosave] bool mbVfx_FOVShakesEnabled = true;
	int mlVfx_FOVShakeID = -1;
	int mlVfx_RollShakeID = -1;
	float mfVfx_ShakeFadeT = 0;
	bool mbCameraRollActive = true;
	
	float mfVfx_LevelPulse = 0.0f;
	float mfVfx_LevelPulseT = 0.0f;
	bool mbVfx_LevelPulseIn = true;
	float mfVfx_LevelPulsePause = 0.0f;
	float mfVfx_AspectLevelMul = 0.0f;
	float mfVfx_PermaFailWarningGradingMul = 0.0f;
	float mfVfx_PermaFailWarningOverlayMul = 0.0f;
	
	float mfNightVisionStrength = 1.0f;
	
	bool mbIsLookingAtScaryEntity=false;
	float mfScaryEntityInViewFearRate=0.f;
	bool mbUpdateScaryViewEffect=false;
	int mlIDRadialBlur=-1;
	float mfRadialBlurPulse=0.f;
	bool mbToggleRadialBlurPulse=false;
	int mlIDImageTrail=-1;
	bool mbOnScreenSound = false;
	
	float mfvfx_TentacleLevel = 0.f;
	float mfVfx_TentacleCriticalPulseMul = 1.f;
	float mfVfx_TentacleCritical = 0.f;
	float mfvfx_TentacleCapBoostTimer = -1.0f;
	eFearTentacleMaterial mvfx_TentacleMaterial = eFearTentacleMaterial_Default;
	
	float mfVfx_StruggleGradingAlpha = 0.f;
	bool mbVfx_StruggleGradingActive = false;
	
	
	void UpdateVisualEffects(float afTimeStep)
	{
		//mbPermaFail_DoWarning = false;
		float fRateMul = cMath_Clamp(mfRate, 0.0f, 1.0f);
			
		/////////////////////////////
		// Fear rate pulse		
		float fTimeMul = 1.0f + (1.0f - fRateMul);
		if (mfVfx_PulseT <= 0.0f || mfVfx_PulseT >= 1.0f)
		{
			if (mfVfx_PulseOutPauseTimer > 0.0f)
			{
				mfVfx_PulseOutPauseTimer -= afTimeStep;				
			}
			else
			{
				mbVfx_PulseIn = !mbVfx_PulseIn;
				if (mbVfx_PulseIn)
				{
					mfVfx_FovPulseTime = cMath_RandRectf(mvVfx_FovPulseTime.x, mvVfx_FovPulseTime.y) * fTimeMul;					
					mfVfx_FovPulseTarget = cMath_RandRectf(mvVfx_PulseFovRange.x, mvVfx_PulseFovRange.y);
					mfVfx_AspectTarget = cMath_RandRectf(mvVfx_PulseAspectRange.x, mvVfx_PulseAspectRange.y);
					mfVfx_RollTarget = cMath_RandRectf(mvVfx_PulseRollRange.x, mvVfx_PulseRollRange.y);
					if (cMath_RandRectl(0, 1) == 0)
					{
						mfVfx_RollTarget = -mfVfx_RollTarget;
					}
				}
				else
				{
					mfVfx_PulseOutPauseTimer = mfVfx_PulseOutPause * fTimeMul;
				}
			}

		}

		if (mbPermaFail_Active)
			mfVfx_FovPulseTime = gfPermaFailTentaclePulseRate;
		if (mfVfx_ForcePulseOutCount > 0.f)
		{
			mfVfx_ForcePulseOutCount -= afTimeStep;
			mbVfx_PulseIn = false;
		}
			
		mfVfx_PulseT = cMath_IncreaseTo(mfVfx_PulseT, 1.0f / mfVfx_FovPulseTime * afTimeStep, mbVfx_PulseIn ? 1.0f : 0.0f);
		mfVfx_Pulse = fRateMul * cMath_Easing(eEasing_SineInOut, mfVfx_PulseT, 0.0f, 1.0f);
		float fFvx_NoRatePulse = cMath_Easing(eEasing_SineInOut, mfVfx_PulseT, 0.0f, 1.0f);

		/////////////////////////////
		// Fear level pulse
		if (mfVfx_LevelPulseT <= 0.0f || mfVfx_LevelPulseT >= 1.0f)
		{
			if (mfVfx_LevelPulsePause > 0.0f)
			{
				mfVfx_LevelPulsePause -= afTimeStep;
			}
			else
			{
				mbVfx_LevelPulseIn = !mbVfx_LevelPulseIn;
				if (mbVfx_LevelPulseIn)
				{
					
				}
				else
				{
					mfVfx_LevelPulsePause = 0.0f;
				}
			}
		}
		float fLevelPulseTime = 0.4f + 0.4f * mfLevel;
		if (mbPermaFail_DoWarning) fLevelPulseTime = 1.5f;
		if (mbPermaFail_Active) mfVfx_LevelPulseT = 1.f;
		mfVfx_LevelPulseT = cMath_IncreaseTo(mfVfx_LevelPulseT, fLevelPulseTime * afTimeStep, mbVfx_LevelPulseIn ? 1.0f : 0.0f);
		mfVfx_LevelPulse = cMath_Easing(eEasing_SineInOut, mfVfx_LevelPulseT, 0.0f, 1.0f);
		
		float fPermaFailWarningGradingTarget = 0.0f;
		if (mbPermaFail_DoWarning || mbPermaFail_Active) fPermaFailWarningGradingTarget = mfVfx_LevelPulse * 0.12f;
		mfVfx_PermaFailWarningGradingMul = cMath_IncreaseTo(mfVfx_PermaFailWarningGradingMul, 0.15f * afTimeStep, fPermaFailWarningGradingTarget);
		//Effect_ToneMapping_SetGradingTexture(eColorGradingPrio_FearFvx_1, "fear_red", mfVfx_PermaFailWarningGradingMul);
		
		float fPermaFailWarningOverlayTarget = 0.0f;
		if (mbPermaFail_DoWarning || mbPermaFail_Active) fPermaFailWarningOverlayTarget = mfVfx_LevelPulse * 0.06f;
		mfVfx_PermaFailWarningOverlayMul = cMath_IncreaseTo(mfVfx_PermaFailWarningOverlayMul, 0.15f * afTimeStep, fPermaFailWarningOverlayTarget);
		//Effect_ToneMapping_SetGradingTexture(eColorGradingPrio_FearFvx_2, "grading_fearlevel_overlay", mfVfx_PermaFailWarningOverlayMul);
		
		/////////////////////////////
		// FOV
		cLux_GetPlayer().SetCameraFOVMul(ePlayerFOVMul_Fear, 1.f + mfVfx_Pulse * -mfVfx_FovPulseTarget);
		
		/////////////////////////////
		// Aspect ratio
		float fAspectLevelMulTarget = 0.2 * mfLevel;
		mfVfx_AspectLevelMul = cMath_IncreaseTo(mfVfx_AspectLevelMul, 0.1f * afTimeStep, fAspectLevelMulTarget);
		Player_FadeAspectMulTo((mfVfx_DefaultAspect - mfVfx_LevelPulse * mfVfx_AspectLevelMul) / mfVfx_DefaultAspect, 0.01f);
		
		/////////////////////////////
		// Camera roll
		if (mbCameraRollActive)
			Player_SetRoll(mfVfx_Pulse * mfVfx_RollTarget);
		
		/////////////////////
		// RadialBlur pulsing
		if (mbToggleRadialBlurPulse)
		{
			mfRadialBlurPulse+=afTimeStep * 3.f;
			if (mfRadialBlurPulse>=1.f)
				mbToggleRadialBlurPulse=false;
		}
		else
		{
			mfRadialBlurPulse-=afTimeStep;
			if (mfRadialBlurPulse<=0.f)
				mbToggleRadialBlurPulse=true;
		}
		
		tString sTerrorSound="player/temp/terror_blur";
		
		if (mbIsLookingAtScaryEntity)
		{
			mbUpdateScaryViewEffect=true;
			if (mbUpdateScaryViewEffect)
			{
				// Fade in Radial Blur
				if (mlIDRadialBlur<0)
					mlIDRadialBlur = Effect_RadialBlur_Start(0.f, 0.f, 1.f, -1);
				Effect_RadialBlur_FadeAlpha(mlIDRadialBlur,cMath_Clamp(mfScaryEntityInViewFearRate,0.f,0.5f), 0.5f);
				Effect_RadialBlur_FadeSize(mlIDRadialBlur, 0.25 * mfRadialBlurPulse, 1.f);
				Effect_RadialBlur_FadeStartDistance(mlIDRadialBlur, 0.1, 0.5f);
				// Fade in Image Trail
				if (mlIDImageTrail<0)
					mlIDImageTrail = Effect_ImageTrail_Start(0.f, 1.f, -1.f, 1.f);
				// Fade in terror sound
				if (mbOnScreenSound == false)
				{
					mbOnScreenSound = true;
//					Sound_PlayGui(sTerrorSound, 0.5f);
//					Sound_FadeGuiVolume(sTerrorSound, 0.0f, 0.0f);
				}
				else
				{
//					Sound_FadeGuiVolume(sTerrorSound, cMath_Clamp(mfScaryEntityInViewFearRate,0.f,1.f), 1.0f);
				}
				
				mbUpdateScaryViewEffect=false;
			}
		}
		else
		{
			mbUpdateScaryViewEffect=true;
			if (mbUpdateScaryViewEffect)
			{
				// Fade out Radial Blur
				if (mlIDRadialBlur >= 0)
				{
					Effect_RadialBlur_FadeSize(mlIDRadialBlur, 0.25 * mfRadialBlurPulse, 1.f);
					Effect_RadialBlur_FadeOut(mlIDRadialBlur, 1.f);
					mlIDRadialBlur = -1;
				}
				// Fade out Image Trail
				if (mlIDImageTrail >= 0)
				{
					Effect_ImageTrail_FadeOut(mlIDImageTrail, 2.f);
					mlIDImageTrail = -1;
				}
				// Fade out terror sound.
				if (mbOnScreenSound)
				{
					mbOnScreenSound = false;
//					Sound_StopGui(sTerrorSound, 2.0f);
				}
				
				mbUpdateScaryViewEffect=false;
			}
		}
		
		/////////////////
		// Struggle grading
		// Note: putting this here since it needs to be faded out when not in the struggle state
		{
			float fGoal = 0.f;
			float fSpeed = 1.f / 1.f;
			
			if (mbVfx_StruggleGradingActive || mbPermaFail_Active && mbPermaFail_BabyMomentActive == false)
			{
				fGoal = 1.f;
				fSpeed = 1.f / 2.f;
			}
			
			float fPrevAlpha = mfVfx_StruggleGradingAlpha;
			mfVfx_StruggleGradingAlpha = cMath_IncreaseTo(mfVfx_StruggleGradingAlpha, afTimeStep * fSpeed, fGoal);
			
			if (mfVfx_StruggleGradingAlpha != fPrevAlpha)
				Effect_ToneMapping_SetGradingTexture(100, gsStruggleGradingTexture, mfVfx_StruggleGradingAlpha);
		}
		
		/////////////////
		// Fear Tentacles
		{
			float fFearRateTarget = GetFearRateTarget();
			float fGoal = 1.f;
			float fSpeed = cMath_Abs(mfRate);
			
			if (mbBabyKickPeace) // Make sure tentacles are visible when they're retracting after a baby kick
			{
				fSpeed = 0.2f;
			}
			else if (fFearRateTarget == 0.f)
			{
				fGoal = 0.f;
				fSpeed = 0.75f;
				if(mfLevel == 1.f)
					fSpeed = 0.5f;
			}
			
			///////////
			// Update 
			float fCurrentStep=mvLevelRegenSteps[mlLevelRegenStep];
			
			// Only increase tentacles halfway to the next cap to make the change more noticeable when moving to the next cap
			// Increase all the way to 1 if at the last cap
			float fTentacleTarget = fCurrentStep + (mfLevel-fCurrentStep) * (mlLevelRegenStep == mvLevelRegenSteps.length() - 1 ? 1.0f : 0.5f);
			fTentacleTarget = cMath_Easing(eEasing_QuadOut, fTentacleTarget); // Make it easier to see tentacles at low fear level
			
			// Tentacle boost when cap is increased
			float fTentacleCapBoostMul = 1.0f;
			float fTentacleBoostAlpha = 0.0f;
			if (mfvfx_TentacleCapBoostTimer > 0)
			{
				if (mfvfx_TentacleCapBoostTimer > 0.5f && mvfx_TentacleMaterial == eFearTentacleMaterial_Default)
				{
					mvfx_TentacleMaterial = eFearTentacleMaterial_Focus;
					Effect_FearTentacles_SetMaterial(mvfx_TentacleMaterial);
				}
				else if (mfvfx_TentacleCapBoostTimer <= 0.5f && mvfx_TentacleMaterial == eFearTentacleMaterial_Focus)
				{
					mvfx_TentacleMaterial = eFearTentacleMaterial_Default;
					Effect_FearTentacles_FadeMaterial(mvfx_TentacleMaterial, 1.0f);
				}
				
				fTentacleBoostAlpha = mfvfx_TentacleCapBoostTimer > 0.5f ?
									  cMath_Clamp((1.0f-mfvfx_TentacleCapBoostTimer)/0.25, 0.0f, 1.0f) :
									  cMath_Clamp(mfvfx_TentacleCapBoostTimer/0.5f, 0.0f, 1.0f);
				
				float fCapBoostSpeed = mfvfx_TentacleCapBoostTimer > 0.5f ? 10.0f : 0.25f;
				
				mfvfx_TentacleCapBoostTimer -= afTimeStep*fCapBoostSpeed;
				if (mfvfx_TentacleCapBoostTimer <= 0)
				{
					mfvfx_TentacleCapBoostTimer = 0;
				}
				
				float fCapExtraMul = mlLevelRegenStep == 1 ? 0.75f : 0.375f;
				float fCapT = ((1.0f-mfvfx_TentacleCapBoostTimer)-0.5)*2.0f; //change timer to -1 to 1 to simplify calculation
				
				
				// use -1 to 0 for fading in and 0 to 1 for fading out
				float fCapEffectIntensity = cMath_Easing(eEasing_QuadOut, 1.0f-cMath_Abs(fCapT));
				Effect_FearTentacles_SetMinVignette(fCapEffectIntensity*1.125f);
				fTentacleCapBoostMul += fCapEffectIntensity*fCapExtraMul;
				
				
				mfvfx_TentacleLevel = fTentacleTarget;
			}
			
			mfTentacleAmount = cMath_IncreaseTo(mfTentacleAmount, afTimeStep * fSpeed, fGoal);			
			mfvfx_TentacleLevel = cMath_IncreaseTo(mfvfx_TentacleLevel, afTimeStep * 1.0f, fTentacleTarget);
			mfPermaFail_TentacleSizeAdd = cMath_IncreaseTo(mfPermaFail_TentacleSizeAdd, afTimeStep * mfPermaFail_TentacleSizeAddSpeed, mfPermaFail_TentacleSizeAddTarget);
			float fTentacleLevel = mfvfx_TentacleLevel * mfFearTentaclesMul * fTentacleCapBoostMul;
			
			// Remap critical
			float fFearCriticalMin = 0.95f;
			float fFearCriticalMax = 1.0f;
			float fCriticalGoal = fTentacleLevel;
			fCriticalGoal -= fFearCriticalMin;
			fCriticalGoal /= fFearCriticalMax - fFearCriticalMin;
			fCriticalGoal = cMath_Clamp(fCriticalGoal, 0.f, 1.f);
			fCriticalGoal = cMath_Easing(eEasing_CircInOut, fCriticalGoal);
			mfVfx_TentacleCritical = cMath_IncreaseTo(mfVfx_TentacleCritical, afTimeStep, fCriticalGoal);
			
			// Remap intensity so it's between 0 and the lower limit of critical
			float fIntensity = RemapValue(cMath_Max(mfVfx_TentacleCritical, mfTentacleAmount) * mfLevel, 0.f, 1.f, 0.f, fFearCriticalMin);
			
			// Remap Amount and use it for speed
			{
				float fSpeedMul = RemapValue(mfTentacleAmount + mfVfx_TentacleCritical * 0.25f, 0.2f, 1.0f);
				Effect_FearTentacles_SetSpeedMul(fSpeedMul);
			}
			
			// Remap level to a mul that fades tentacles in between 0 and 0.05
			float fAlphaMul = RemapValue(fTentacleLevel,0.f, 1.f, 0.f, 0.05);
			
			// Get alpha
			float fFearAlphaMin = 0.675f;
			float fFearAlphaMax = 1.2f;
			float fAlphaAmount = cMath_Max(mfTentacleAmount, fTentacleBoostAlpha);
			float fFearAlpha = RemapValue(cMath_Easing(eEasing_QuintOut, fAlphaAmount), fFearAlphaMin, fFearAlphaMax) * fAlphaMul;
						
			// Critical scale add
			float fCriticalScaleAddPulse = RemapValue(mfTentacleAmount, 1.0f, 2.0f);			
			mfVfx_TentacleCriticalPulseMul = cMath_IncreaseTo(mfVfx_TentacleCriticalPulseMul, afTimeStep, mfTentacleCriticalMulGoal);
			float fCriticalPulse = RemapValue(fFvx_NoRatePulse, 0.35, 1.0f) * mfVfx_TentacleCriticalPulseMul;
			
			// Set effect variables
			Effect_FearTentacles_SetCoverage(fTentacleLevel);
			Effect_FearTentacles_SetAlpha(fFearAlpha);
			Effect_FearTentacles_SetIntensity(fIntensity);
			Effect_FearTentacles_SetCritical(mfVfx_TentacleCritical * mfTentacleAmount);
			Effect_FearTentacles_SetScaleAdd(mfPermaFail_TentacleSizeAdd + (mfVfx_TentacleCritical * fCriticalPulse * mfTentacleAmount * fCriticalScaleAddPulse));
		}
		
		///////////////////////////
		// Darkness shakes
		if (mbVfx_FOVShakesEnabled && mfDarknessFactor > 0 && fRateMul > 0)
		{
			if (mlVfx_FOVShakeID == -1)
				mlVfx_FOVShakeID = Effect_FOV_Shake_Start(0, -1, 0, 0, 0, true, 0.05f, gfShake_NoiseSpeed, false);
			if (mlVfx_RollShakeID == -1)
				mlVfx_RollShakeID = Effect_Roll_Shake_Start(0, -1, 0, 0, 0, true, 0.05f, gfShake_NoiseSpeed);
			
			float fShakeFadeTime = gfShake_MinFadeInTime + ((gfShake_MaxFadeInTime-gfShake_MinFadeInTime) * mfLevel); // Fade in slower at higher levels since the effect is more intense
			mfVfx_ShakeFadeT = cMath_IncreaseTo(mfVfx_ShakeFadeT, afTimeStep/fShakeFadeTime, 1.0f);
			
			float fFOVShakeStrength = gvFovShake_CapBaseStrength[mlLevelRegenStep] + gfFovShake_FearStrength * cMath_Easing(eEasing_QuadIn, mfLevel-GetCurrentLevelRegenCap());
			float fRollShakeStrength = gvRollShake_CapBaseStrength[mlLevelRegenStep] + gfRollShake_FearStrength * cMath_Easing(eEasing_QuadIn, mfLevel-GetCurrentLevelRegenCap());
			
			float fMoveMul = 1.0f;
			if (Player_GetSpeed() > 1.0f)
				fMoveMul = 1.0f + (gfShake_MoveMul-1.0f)*(1.0f-mfLevel);
			
			// Use noise to decide when the effect should be maximized
			float fSpikeNoise = cGenerate_GetNoisePerlin1D(cEngine_GetGameTime()*10.0f);
			if (fSpikeNoise < 0.65)
				fSpikeNoise = 0.25f;
			else
				fSpikeNoise = 1.0f;
				
			//cLux_AddDebugMessage("Roll max "+fRollShakeStrength * fMoveMul);
			//cLux_AddDebugMessage("FOV max "+fFOVShakeStrength * fMoveMul);
			Effect_FOV_Shake_SetAmount(mlVfx_FOVShakeID, fFOVShakeStrength * cMath_Easing(eEasing_CubicIn, mfVfx_ShakeFadeT) * fMoveMul * fSpikeNoise);
			Effect_Roll_Shake_SetAmount(mlVfx_RollShakeID, fRollShakeStrength * cMath_Easing(eEasing_CubicIn, mfVfx_ShakeFadeT) * fMoveMul * fSpikeNoise);
		}
		else
		{
			if (mlVfx_FOVShakeID >= 0)
				Effect_FOV_Shake_FadeOut(mlVfx_FOVShakeID, 0.5);
			if (mlVfx_RollShakeID >= 0)
				Effect_Roll_Shake_FadeOut(mlVfx_RollShakeID, 0.5);
				
			mlVfx_FOVShakeID = -1;
			mlVfx_RollShakeID = -1;
			mfVfx_ShakeFadeT = 0;
		}
	}
	
	//------------------------------------------------------------
	
	void DoTentacleBoost()
	{
		mfvfx_TentacleCapBoostTimer = 1.f;
	}
	
	//------------------------------------------------------------
	
	void SetCameraRollActive(bool abActive)
	{
		mbCameraRollActive = abActive;
	}
	
	//------------------------------------------------------- 
	
	float mfTentacleAmount = 0.f;
	float mfTentacleCriticalMulGoal = 1.f;
	
	//------------------------------------------------------------
	
	void FadeTentacleSizeAddTo(float afSizeTarget, float afTime)
	{
		mfPermaFail_TentacleSizeAddTarget = afSizeTarget;
		
		float fTime = cMath_Max(afTime, 0.0001f);
		mfPermaFail_TentacleSizeAddSpeed = cMath_Abs(afSizeTarget - mfPermaFail_TentacleSizeAdd) / fTime;
	}
	
	//------------------------------------------------------------
	
	float RemapValue(float afX, float afNewLow, float afNewHigh, float afOldLow = 0.f, float afOldHigh = 1.f)
	{
		return cMath_Clamp(afNewLow + (afX - afOldLow) * (afNewHigh - afNewLow) / (afOldHigh - afOldLow), afNewLow, afNewHigh);
	}
	
	//------------------------------------------------------------
	
	void SetStruggleGradingTextureActive(bool abX)
	{
		mbVfx_StruggleGradingActive = abX;
	}
	
	//------------------------------------------------------------
	
	float mfFearAreaMusicTimer = 0.0f;
	int mlFearAreaMusicState = 0;
	int mlAudioUpdateIndex = 0;
	float mfSafeMusicVol = 0.2f;
	
	[nosave] int m_idAudio_BreathingLoop = -1;
	[nosave] int m_idAudio_FearSystemLoop = -1;
	
	bool mbAudio_PermaFailWarningOn = false;
	[nosave] tID m_idAudio_PermaFailWarning = tID_Invalid;
	
	bool mbAudio_CracklingOn = false;
	[nosave] tID m_idAudio_Crackling = tID_Invalid;
	
	void UpdateAudio(float afTimeStep)
	{
		if (mbActive == false) return;
		
		++mlAudioUpdateIndex;
		if (mlAudioUpdateIndex >= 11) mlAudioUpdateIndex = 0;
        
		/////////////////////////////
		// Fear level and rate
		if (gbFearSound_FearSystemLoop_Active)
		{
			if (m_idAudio_FearSystemLoop<0)
				m_idAudio_FearSystemLoop = PlayerEmotion_PlaySound(eEmotionPlaylistType_Heartbeat, eEmotionSoundType_FearLoop, 0, gsFearSound_FearSystemLoop, -1, 0.25f, 0.25f);
			else
				PlayerEmotion_SetSoundParams(eEmotionPlaylistType_Heartbeat, m_idAudio_FearSystemLoop, mfRate, mfFocus, mfLevel, 0);
		}

		/////////////////////////////
		// Breathing
		if (gbFearSound_Breathing_Active)
		{
			if (m_idAudio_BreathingLoop<0)
			{
				m_idAudio_BreathingLoop = PlayerEmotion_PlaySound(eEmotionPlaylistType_Breathing, eEmotionSoundType_FearLoop, 0, gsFearSound_Breathing, -1, 1.f, 0.25f);
			}
			else
			{
				// Don't breathe if only factor is darkness!
				float fRateParam = mfRate - GetFactors(true, false, false, false, false, false, false);
				if (fRateParam > 0.f)
					fRateParam = mfRate;
				
				PlayerEmotion_SetSoundParams(eEmotionPlaylistType_Breathing, m_idAudio_BreathingLoop, fRateParam, mfFocus, mlLevelRegenStep, mfLevel);
			}
		}
		
		/////////////////////////////
		// Crackling
		if (mlAudioUpdateIndex == 7 && gbFearSound_Crackling_Active)
		{
			
			//////////////////////////////////////
			// See if sounds needs to be created
			if (m_idAudio_Crackling == tID_Invalid)
			{
				Sound_CreateAtEntity("FearSound_Crackling", gsFearSound_Crackling, "player", 0, false, 0);
				cSoundEntity@ pSound = cLux_GetCurrentMap().GetWorld().GetSoundEntity("FearSound_Crackling");
				if (pSound !is null) m_idAudio_Crackling = pSound.GetID();
			}
			
			
			///////////////////////////////////////
			// Update the sound
			if (m_idAudio_Crackling != tID_Invalid)
			{
				cSoundEntity@ pSound = cLux_ID_SoundEntity(m_idAudio_Crackling);
				if (pSound !is null)
				{
					float fBaseVolume = 0;
					float fParam = 0;

					if (cLux_GetPlayer().GetCurrentStateId() != ePlayerState_Custom_CheckBaby ||
						IsAgentNearby())
					{
						if (mfCracklingLevel > 0.01f) fBaseVolume = 1;
						
						fParam = 0.2f + mfCracklingLevel * (1.1f-0.2f); //Range = 0.2 - 1.1
					}
					
					//cLux_AddDebugMessage("Level:"+mfCracklingLevel+"Param: "+fParam);
				
					pSound.FadeVolumeMul(fBaseVolume, 1.0);
					pSound.SetParam("sanity_level", fParam);
					pSound.SetParam("FearLevel", fParam);
				}
				else
				{
					m_idAudio_Crackling = tID_Invalid;
				}
			}
			
			mfCracklingLevel = 0;
		}
		
		/////////////////////////////
		// Perma fail siren
		if (mlAudioUpdateIndex == 8 && gbFearSound_PermaFailWarning_Active)
		{
			if (m_idAudio_PermaFailWarning == tID_Invalid)
			{
				Sound_CreateAtEntity("FearSound_PermaFailWarning", gsFearSound_PermaFailWarning, "player", 1.0f, false, 0.0f);
				cSoundEntity@ pSound = cLux_GetCurrentMap().GetWorld().GetSoundEntity("FearSound_PermaFailWarning");
				if (pSound !is null) m_idAudio_PermaFailWarning = pSound.GetID();
			}
			else
			{
				bool bShouldBeOn = mbPermaFail_DoWarning && mbPaused == false;
				if (mbAudio_PermaFailWarningOn == false && bShouldBeOn)
				{
					mbAudio_PermaFailWarningOn = true;
					cSoundEntity@ pSound = cLux_ID_SoundEntity(m_idAudio_PermaFailWarning);
					if (pSound is null) m_idAudio_PermaFailWarning = tID_Invalid;
					else pSound.FadeVolumeMul(1.0f, 1.0f);
				}
				else if (mbAudio_PermaFailWarningOn && bShouldBeOn == false)
				{
					mbAudio_PermaFailWarningOn = false;
					cSoundEntity@ pSound = cLux_ID_SoundEntity(m_idAudio_PermaFailWarning);
					if (pSound is null) m_idAudio_PermaFailWarning = tID_Invalid;
					else pSound.FadeVolumeMul(0.0f, 1.0f);
				}
			}
		}
		
		/////////////////////////////
		// Fear area music
		mfFearAreaMusicTimer -= afTimeStep;
		if (mlAudioUpdateIndex == 9 && gbFearSound_FearAreaMusic_Active && mfFearAreaMusicTimer <= 0.0f)
		{
			mfFearAreaMusicTimer = cMath_RandRectf(0.15f, 0.2f);
			
			if (mlFearAreaMusicState != 0 && mFearAreaState == eFearAreaState_None)
			{
				mlFearAreaMusicState = 0;
				Music_Stop(4.0f, eMusicPrio_SceneAmb);
				mBaseObj.Timer_Remove("Timer_StartSafeMusic");
			}
			else if (mlFearAreaMusicState != 1 && IsSituationSafe() == false && mFearAreaState != eFearAreaState_None)
			{
				mlFearAreaMusicState = 1;
				Music_Stop(4.0f, eMusicPrio_SceneAmb);
			}
			else if (mlFearAreaMusicState != 2 && IsSituationSafe() && mFearAreaState != eFearAreaState_None)
			{
				mlFearAreaMusicState = 2;
				Music_Stop(2.0f, eMusicPrio_SceneAmb);
				mBaseObj.Timer_Add("Timer_StartSafeMusic", 0.5f, "OnTimer_StartSafeMusic");
			}		
		}
		
		/////////////////////////////
		// Whispers
		if (mlAudioUpdateIndex == 10 && gbFearSound_WhispersActive)
		{
			UpdateWhispers(afTimeStep);
		}
		
		if (mfGaspCooldown > 0.0f)
		{
			mfGaspCooldown -= afTimeStep;
		}
	}
	
	void OnTimer_StartSafeMusic(uint64 alID)
	{
		Music_PlayExt(mActiveFearArea.msSafeMusic, true, mfSafeMusicVol, 1.0f, 4.0f, 0.0f, eMusicPrio_SceneAmb, true);
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	float mfLevelAddSpeed = 1.0f;

	float mfLevelAddAmount = 0.0f;
	bool mbLevelAddIncrease = false;
	
	
	float mfLevelFade_FadeTimer = 0.0f;
	float mfLevelFade_Speed = 0.0f;
	float mfLevelFade_Target = 0.0f;
	bool mbLevelFade_Active = false;
	bool mbLevelFade_IgnoreRegenCap = false;
	
	void UpdateFearAdditions(float afTimeStep)
	{
		if (mfLevelAddAmount != 0.0f)
		{
			float fAdd = mfLevelAddSpeed * afTimeStep;
			mfLevelAddAmount -= fAdd;
			if (mfLevelAddAmount < 0.0f)
			{
				fAdd += mfLevelAddAmount;
				mfLevelAddAmount = 0.0f;
			}
			mfLevel += mbLevelAddIncrease ? fAdd : -fAdd;
		}
		
		if (mbLevelFade_Active)
		{
			mfLevelFade_FadeTimer -= afTimeStep;
			mfLevel = cMath_IncreaseTo(mfLevel, mfLevelFade_Speed * afTimeStep, mfLevelFade_Target);
			if (mfLevelFade_FadeTimer <= 0.0f)
			{
				mfLevel = mfLevelFade_Target;
				mbLevelFade_Active = false;
				if (mbLevelFade_IgnoreRegenCap)
				{
					mbLevelRegenCapActive = true;
					mlLevelRegenStep = GetClosestRegenStep(mfLevel);
				}
			}
		}
	}
	
	//------------------------------------------------------------
	
	float mfUpdateFocusTimer = 0;
	void UpdateFocus(float afTimeStep)
	{
		mfUpdateFocusTimer -= afTimeStep;
		if (mfUpdateFocusTimer >= 0) return;
		mfUpdateFocusTimer = cMath_RandRectf(0.1, 0.2);
		
		float fFocusTarget = 0.0f;
		float fSpeed = Player_GetVelocity().Normalize();
		bool bCrouching = Player_GetCrouching();
		if (bCrouching && fSpeed < 0.05f) fFocusTarget = 1.0f;
		if (bCrouching && fSpeed >= 0.05f) fFocusTarget = 0.55f;
		if (bCrouching == false && fSpeed < 0.05f) fFocusTarget = 0.25f;
		if (bCrouching == false && fSpeed >= 0.05f) fFocusTarget = 0.0f;
		
		mfFocus = cMath_IncreaseTo(mfFocus, (1.0f / 3.5f) * afTimeStep, 0.65f * fFocusTarget);
	}
	
	//------------------------------------------------------------
	
	array<float> mvLevelRegenSteps = { 0.00f, 0.33f, 0.67f };
	array<float> mvLevelRegenThresholds = { 0.5, 0.84f };
	
	uint mlLevelRegenStep = 0;
	bool mbLevelRegenCapActive = true;
	bool mbLevelCapIncreasedGui = false;
	bool mbIncreaseLevelCapOverlay = false;
	
	bool GetPlayerPastLastCap()
	{
		return (mlLevelRegenStep == mvLevelRegenSteps.length()-1);
	}

	void UpdateLevelRegenCap(float afTimeStep)
	{
		if (mbLevelRegenCapActive == false) return;
		if (IsSituationSafe()) return;
		if (mfRate < 0.0f) return;
		if (mlLevelRegenStep + 1 >= mvLevelRegenSteps.size()) return;
		float fNextThreshold = mvLevelRegenThresholds[mlLevelRegenStep];
		if (mfLevel >= fNextThreshold)
		{
			IncreaseLevelCap();
		}
	}
	
	float GetCurrentLevelRegenCap()
	{
		return mvLevelRegenSteps[mlLevelRegenStep];
	}
	
	void IncreaseLevelCap()
	{
		++mlLevelRegenStep;		
		mbIncreaseLevelCapOverlay = true;
		mfWhisperCapBoost = WHISPER_CAP_BOOST;
		
		// Don't do the cap effects if currently thrown!
		if (cLux_GetPlayer().GetCurrentStateId() != ePlayerState_Custom_Thrown)
		{
			mfvfx_TentacleCapBoostTimer = 1.0f;
			StruggleFlashHandler_DoFlash(0, 0, false);
		}
	}	
	
	void IncreaseLevelRegenCap()
	{
		Debug_Log("INCREASED CAP");
		mfLevel = mvLevelRegenSteps[mlLevelRegenStep];
		if (mlLevelRegenStep + 1 >= mvLevelRegenSteps.size()) return;
		mlLevelRegenStep++;		
	}
	
	//------------------------------------------------------------
	
	void Update(float afTimeStep)
	{
		// TODO: Put this in VariableUpdate when it works with screen effects
		UpdateBabyKicks(afTimeStep);
	}
	
	void PostUpdate(float afTimeStep) {}
	
	//------------------------------------------------------------
	
	void Reset() 
	{
		mbPermafail_WakeUpSoundsAllowed = true;
	}
	
	//------------------------------------------------------------
	
	//} END OF GEMERAL
	
	/////////////////////////////////////////
	// PERMAFAIL
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbPermaFail_Enabled = true;
	bool mbPermaFail_Active = false;
	bool mbPermafail_BabyMomentEnabled = false;
	bool mbPermafail_BabyMomentEnabled_AutoReset = true;
	bool mbPermaFail_BabyMomentActive = false;
	cVector3f mvPermafail_BabyMomentCamTarget;
	cVector3f mvPermafail_BabyMomentCamVel;
	int mlPermafail_mlTentaclePulsesLeft = 0;
	bool mbPermaFail_DoWarning = false;
	bool mbPermaFail_SecondChance = true;
	bool mbPermaFail_RandCamRot = false;
	bool mbPermaFail_PlayGhoulBreathing = true;
	bool mbPermaFail_VolumeResetOnCustomPermaFail = true;
	bool mbPermaFail_UseTriggerAnim = true;
	bool mbPermaFail_TriggerWhenInNormalState = false;
	bool mbPermaFail_PlayVocals = true;
	float mfPermaFail_RandomLookDirUpdateTime = 0.f;
	int mlPermaFail_TotalTimesTriggered = 0;
	int mlPermaFail_StruggleCount = 0;
	int mlPermaFail_PrevGhoulLevel = 0;
	int mlPermaFail_PermaFailCount = 0;
	float mfPermaFail_TriggerCount = 0.f;	
	float mfPermaFail_HuntImmunityCount = 0.f;		
	float mfPermaFail_IntroCount = 0.f;
	float mfPermaFail_WarningFlashCount = 1.f;
	float mfPermafail_WarningFlashCount_RateDelay = 5.0f;
	bool mbPermaFail_PlayedQuickWarningFlash = false;
	bool mbPermaFail_ScenesActive = false;
	bool mbPermafail_WakeUpActive = false;
	bool mbPermafail_WakeUpSoundsAllowed = true;
	int mlPermaFail_IntroStage = -1;
	bool mbPermafail_FastFadeOut = false;
	int mlPermaFail_SceneId = -1;
	int mlPermaFail_BlurId = -1;
	int[] mvPermafail_ScreenEffectIDs = {-1, -1};
	float mfPermaFail_TentacleSizeAdd = 0;
	float mfPermaFail_TentacleSizeAddTarget = 0;
	float mfPermaFail_TentacleSizeAddSpeed = 1.f;
	int mlPermaFail_FOVShakeID = -1;
	float mfPermaFail_ExtraSceneDelay = 0.f;
	float mfPermaFail_ClosestAgentDist = -1;
	float mfPermaFail_ClosestAgentDistTimer = 0;
	float mfPermaFail_ClosestAgentImmunityTimer = 0;
	tString msPermaFail_TriggerAnim = "";
	tString msPermaFail_WakeUpArea = "";
	eMusicPrio mPermafail_WakeUpMusicPrio = eMusicPrio_SceneAmb;
	tString msPermaFail_WakeUpAnim = "";
	tString msPermafail_Source = "";
	array<cPermaFailScene> mvPermaFail_Scenes;
	array<cPermaFailSenario> mvPermaFail_Senarios;
	bool mbPermaFailedOnce = false;
	bool mbPermafail_SkyboxActive = false;
	bool mbPermafail_DirLightActive = false;
	bool mbPermafail_FogActive = false;
	bool mbPermafail_SecondaryFogActive = false;
	bool mbPermafail_RestoreVertigo = true;
	bool mbPermafail_SoundLoopActive = false;
	bool mbPermafail_AutoStopSoundLoop = true;
	float mfPermafail_AutoStopSoundLoopDelay = -1.0f;
	
	//------------------------------------------------------------
	
	void SetPermaFailEnabled(bool abEnabled)
	{		
		mbPermaFail_Enabled = abEnabled;
	}
	
	//------------------------------------------------------------
	
	bool GetPermaFailEnabled()
	{
		return mbPermaFail_Enabled;
	}
	
	//------------------------------------------------------------
	
	bool GetIsPermaFailing()
	{
		return mbPermaFail_Active;
	}
	
	//------------------------------------------------------------
	
	void SetWakeUpSoundsAllowed(bool abAllowed)
	{
		mbPermafail_WakeUpSoundsAllowed = abAllowed;
	}
	
	//------------------------------------------------------------
	
	void SetPermaFailRandCamRotActive(const bool abActive)
	{
		mbPermaFail_RandCamRot = abActive;
	}
	
	//------------------------------------------------------------
	
	void SetPermaFailStruggleEnabled(bool abEnabled)
	{
		mbPermaFail_SecondChance = abEnabled;
	}
	
	//------------------------------------------------------------
	
	void SetVolumeResetOnCustomPermaFail(bool abX)
	{
		mbPermaFail_VolumeResetOnCustomPermaFail = abX;
	}
	
	//------------------------------------------------------------
	
	void SetPlayPermaFailGhoulBreathing(bool abX)
	{
		mbPermaFail_PlayGhoulBreathing = abX;
	}
	
	//------------------------------------------------------------
	
	void SetPermafailBabySceneEnabled(bool abX, bool abAutoReset)
	{
		mbPermafail_BabyMomentEnabled = abX;
		mbPermafail_BabyMomentEnabled_AutoReset = abAutoReset;
	}
	
	//------------------------------------------------------------
	
	void AddPermaFailScene(const tString &in asPlayerAnim, const tString &in asEntity, const tString &in asAnimEntity, 
						   const tString &in asEntityAnim, float afDuration, bool abRandomLookDir = false)
	
	{
		cPermaFailScene scene;
		scene.mlType = ePermaFailSceneType_PlayerAnim;
		scene.msPlayerAnim = asPlayerAnim;
		scene.msEntity = asEntity;
		scene.msAnimEntity = asAnimEntity;
		scene.msEntityAnim = asEntityAnim;
		scene.mfDuration = afDuration;
		scene.mbRandomLookDirActive = abRandomLookDir;
		scene.mbCrouch = false;
		
		mvPermaFail_Scenes.push_back(scene);
	}
	
	//------------------------------------------------------------
	
	void AddPermaFailScene(const tString &in asMoveStartEnt, const tString &in asMoveEndEnt, float afMoveSpeed, 
						   float afDuration, bool abRandomLookDir = true, bool abCrouch = false)
	
	{
		cPermaFailScene scene;
		scene.mlType = ePermaFailSceneType_PlayerMove;
		scene.msEntity = asMoveStartEnt;
		
		iLuxEntity@ pStartEnt = cLux_GetCurrentMap().GetEntityByName(asMoveStartEnt);
		if (pStartEnt is null)
		{
			Error("No entity with name '" + asMoveStartEnt + "' found for FearHandler_AddPermaFailScene!");
			return;
		}
	
		iLuxEntity@ pEndEnt = cLux_GetCurrentMap().GetEntityByName(asMoveEndEnt);
		if (pEndEnt is null)
		{
			Error("No entity with name '" + asMoveEndEnt + "' found for FearHandler_AddPermaFailScene!");
			return;
		}
		
		scene.mvMoveStart = pStartEnt.GetPosition();
		scene.mvMoveEnd = pEndEnt.GetPosition();		
		scene.mfMoveSpeed = afMoveSpeed;
		scene.mfDuration = afDuration;
		scene.mbRandomLookDirActive = abRandomLookDir;
		scene.mbCrouch = abCrouch;
		
		mvPermaFail_Scenes.push_back(scene);
	}
	
	//------------------------------------------------------------
	
	void AddPermaFailScene(const tString &in asCameraAnim, float afDuration)
	{
		cPermaFailScene scene;
		scene.mlType = ePermaFailSceneType_CameraAnim;
		scene.msCameraAnim = asCameraAnim;
		scene.mfDuration = afDuration;
		scene.mbRandomLookDirActive = false;
		scene.mbCrouch = false;
		
		mvPermaFail_Scenes.push_back(scene);
	}
	
	//------------------------------------------------------------
	
	void ClearPermaFailScenes()
	{
		mvPermaFail_Scenes.resize(0);
		mvPermaFail_Senarios.resize(0);
	}
	
	//------------------------------------------------------------
	
	void SetPermaFailRespawnArea(const tString &in asArea)
	{
		cLux_AddDebugMessage("[FearHandler] PermaFail Respawn Area: " + asArea);
		msPermaFail_WakeUpArea = asArea;
	}
	
	//------------------------------------------------------------
	
	tString GetPermFailRespawnArea()
	{
		return msPermaFail_WakeUpArea;
	}
	
	//------------------------------------------------------------
	
	void SetPermaFailWakeUpMusicPrio(int alPrio)
	{
		mPermafail_WakeUpMusicPrio = eMusicPrio(alPrio);
		cLux_AddDebugMessage("Setting prio to "+mPermafail_WakeUpMusicPrio);
	}
	
	//------------------------------------------------------------
	
	void SetPermaFailTriggerAnimation(const tString &in asAnim)
	{
		msPermaFail_TriggerAnim = asAnim;
	}
	
	//------------------------------------------------------------
	
	void SetUsePermaFailTriggerAnimation(bool abX)
	{
		mbPermaFail_UseTriggerAnim = abX;
	}
	
	//------------------------------------------------------------
	
	void StopPermaFailScenes()
	{
		ClearPermaFailScenes();
		
		mbPermaFail_ScenesActive = false;
		
		mBaseObj.Timer_Remove("Timer_PermaFailScene_Prepare");
		mBaseObj.Timer_Remove("Timer_PermaFailScene_PositionPlayer");
		mBaseObj.Timer_Remove("Timer_PermaFailScene_Start");
		mBaseObj.Timer_Remove("Timer_PermaFailScene_End");
		mBaseObj.Timer_Remove("Timer_PermaFailScene_FadeOut");
		
		FadeTentacleSizeAddTo(0.f, 1.f);
		Effect_ImageTrail_Clear();
		Effect_FOV_Shake_FadeOut(mlPermaFail_FOVShakeID, 0);
		
		mfVfx_ForcePulseOutCount = 0.f;
		mfTentacleCriticalMulGoal = 1.f;
		mbPermaFail_RandCamRot = false;
		mbPermaFail_PlayGhoulBreathing = true;
		mfPermaFail_ExtraSceneDelay = 0.f;
		mbPermaFail_VolumeResetOnCustomPermaFail = true;
		mbPaused = false;
		mbPermaFail_Active = false;
		
		cLuxPlayer@ pPlayer = cLux_GetPlayer();
		pPlayer.StopCameraRotate(0.f);
		pPlayer.StopAutomoveCharBody();
		pPlayer.SetActive(true);
		pPlayer.GetCharacterBody().SetActive(true);
		pPlayer.GetCharacterBody().SetCustomGravityActive(false);
		pPlayer.ChangeState(ePlayerState_Normal);		
		
		Player_SetMoveSpeedMul(1.f, ePlayerMoveSpeedMulType_Fear);
		Player_SetLookSpeedMul(1.f);
		Player_ShowCrossHairIcons(true);
		
		Pregnancy_SetBarksActive(true);
		
		Sound_FadeGlobalVolume(1.f, 1.f, eSoundEntryType_WorldAll);
			
		FadeLevelTo(0.f, 2.f, true);
		FadeTentacleSizeAddTo(0.f, 0.1f);
	}
	
	//------------------------------------------------------------

	void UpdatePermaFail(float afTimeStep)
	{
		/////////////////
		// Setup
		cLuxPlayer@ pPlayer = cLux_GetPlayer();
		
		/////////////////
		// Delayed trigger?
		if (mbPermaFail_TriggerWhenInNormalState && pPlayer.GetCurrentStateId() == ePlayerState_Normal)
		{
			mbPermaFail_TriggerWhenInNormalState = false;
			TriggerPermaFail(true, msPermafail_Source);
		}
		
		/////////////////
		// Currently permafailing?
		if (mbPermaFail_Active)
		{				
			/////////////////
			// Do intro
			mfPermaFail_IntroCount -= afTimeStep;
			if (mfPermaFail_IntroCount <= 0.f)
			{
				if (mlPermaFail_IntroStage == 0)
				{
					/////////////////
					// Set up anim
					cMeshEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(PlayerBody_GetEntityName()).GetMeshEntity();
					iCharacterBody@ pBody = cLux_GetPlayer().GetCharacterBody();
					
					tString sAnim = msPermaFail_TriggerAnim == "" ? "permafail_trigger" : msPermaFail_TriggerAnim;
					msPermaFail_TriggerAnim = "";
					
					/////////////////
					// Should a crouched version of the anim play?
					bool bFits = false;					
					cVector3f vTempOutVec;
					cVector3f[] vStandTestAdd = { cVector3f(0.f, 0.001f, 0.f), cVector3f(0.05f, 0.001f, 0.f), 
												  cVector3f(-0.05f, 0.001f, 0.f), cVector3f(0.f, 0.001f, 0.05f), 
												  cVector3f(0.f, 0.001f, -0.05f) };
					for (int i = 0; i < 5; i++)
					{
						if (pBody.CheckCharacterFits(pBody.GetFeetPosition() + vStandTestAdd[i], true, 0, vTempOutVec))
						{
							bFits = true;
							break;
						}
					}
					
					if (bFits == false || Player_GetCrouching())
					{
						if (pEnt.GetAnimationStateFromName(sAnim + "_crouch") !is null)
							sAnim += "_crouch";
						else
							sAnim = "permafail_trigger_crouch";
					}					
					
					/////////////////
					// Set up player										
					Player_FadeMoveSpeedMulTo(0.1f, gfPermaFailFadeInTime, ePlayerMoveSpeedMulType_Fear);
					Player_FadeLookSpeedMulTo(0.1f, gfPermaFailFadeInTime);
					
					if (mbPermaFail_UseTriggerAnim)
					{
						PlayerBody_FadeCutsceneMaxPitch(10.f, 1.f);
						PlayerBody_FadeCutsceneMaxYaw(10.f, 1.f);
						PlayerBody_PlayCutsceneAnimation(sAnim, false, 0.5f);
					}
					
					mbPermaFail_UseTriggerAnim = true;
					
					/////////////////
					// Start effects
					Effect_ImageTrail_Start(2.f, 0.2f, 4.f, 1.f);
					Effect_Shake_Start(0.01f, 1.f, gfPermaFailFadeInTime, 1.f);
					
					FadeTentacleSizeAddTo(0.f, 0.75f);
					mfVfx_ForcePulseOutCount = 0.75f;
					
					mfPermaFail_IntroCount = 0.75f;
					mlPermaFail_IntroStage++;
					
					PlayStruggleSoundLoop(3.f, 0.5f, false);
				}
				else if (mlPermaFail_IntroStage == 1)
				{
					mfTentacleCriticalMulGoal = 2.5f;
					
					mfPermaFail_IntroCount = gfPermaFailFadeInTime - 0.75f;
					mlPermaFail_IntroStage++;
				}
				else if (mlPermaFail_IntroStage == 2)
				{
					FadeTentacleSizeAddTo(25.f, mbPermafail_FastFadeOut ? 0.2 : 0.4f);
					
					Sound_Fade("Sound_PermaFail", 0.f, 0.1f);
					Sound_Stop("Sound_StruggleLoop", 0.1f);
					StopStruggleSoundLoop(0.5);
					
					Sound_FadeGlobalVolume(0.f, 0.15f, eSoundEntryType_WorldAll);
					
					Music_FadeVolumeMul(0, 1.0f);
					
					mfPermaFail_IntroCount = mbPermafail_FastFadeOut ? 0.075 : 0.15f;
					mlPermaFail_IntroStage++;
				}
				else if (mlPermaFail_IntroStage == 3)
				{
					Player_ShowCrossHairIcons(false, true);
					pPlayer.SetActive(false);

					mfPermaFail_IntroCount = mbPermafail_FastFadeOut ? 0.05 : 0.1f;
					mlPermaFail_IntroStage++;
				}
				else if (mlPermaFail_IntroStage == 4)
				{
					Effect_Fade_Out(mbPermafail_FastFadeOut ? 0.05 : 0.1f);
					mbPermafail_FastFadeOut = false;
					
					mfPermaFail_IntroCount = 2.8f;
					mlPermaFail_IntroStage++;
				}
				else if (mlPermaFail_IntroStage == 5)
				{								
					// Start permafail!
					StartPermaFail(msPermafail_Source);
					
					mfPermaFail_IntroCount = 0.f;
					mlPermaFail_IntroStage = -1;
				}
			}
			
			/////////////////
			// Camera Random Rotation 
			if (mbPermaFail_RandCamRot)
			{
				mfPermaFail_RandomLookDirUpdateTime+=afTimeStep;
				bool bBigMove = cMath_RandRectf(0,1)>=0.7?true:false;
				float fFastThreshold = cMath_RandRectf(0.1,1.5f);
				float fSlowThreshold = fFastThreshold * 2;
				float fUpdateThreshold = !bBigMove ? fFastThreshold : fSlowThreshold;
					
				if (mfPermaFail_RandomLookDirUpdateTime >= fUpdateThreshold)
				{
					cLux_GetPlayer().StopCameraRotate(0.5);
					// Get random camera direction
					float fRandRotAmount = 0.55;
					float fAccel=1;
					float fSpeedMul=2;
					float fMaxSpeed=cMath_RandRectf(4.f,8.f);
					cVector3f vRandomDirection = cMath_RandRectVector3f(cVector3f_MinusOne * fRandRotAmount, cVector3f_One * fRandRotAmount);
					
					if (bBigMove)
					{
						fRandRotAmount*=1.0;
						fMaxSpeed*=2;
						fAccel*=2;
						fSpeedMul*=1.5f;
					}
					
					vRandomDirection.y *= 0.15f;
					
					// Rotate camera
					cVector3f vLookDirection = cLux_GetPlayer().GetCamera().GetForward() + vRandomDirection;
					cLux_GetPlayer().RotateCameraTowards(fAccel, fSpeedMul, fMaxSpeed, vLookDirection, true);
					mfPermaFail_RandomLookDirUpdateTime=0;
				}
			}
		}
		
		///////////////////
		// Update baby moment camera
		if (mbPermaFail_BabyMomentActive)
		{
			cVector3f vCurrCamAdd = cLux_GetPlayer().GetCameraPosAdd(eCameraAddType_Permafail_Add);
			cVector3f vToTarget = mvPermafail_BabyMomentCamTarget-vCurrCamAdd;
			//vToTarget = cMath_Vector3Normalize(vToTarget);
			
			mvPermafail_BabyMomentCamVel *= 1.0f-afTimeStep*1.0f;
			mvPermafail_BabyMomentCamVel += vToTarget*afTimeStep*1.0f;
			//mvPermafail_BabyMomentCamVel = vToTarget;
			
			cLux_GetPlayer().SetCameraPosAdd(eCameraAddType_Permafail_Add, vCurrCamAdd+mvPermafail_BabyMomentCamVel*afTimeStep);
		}
		
		/////////////////
		// Give immunity to permafailing if hunted
		bool bHunted = Blackboard_GetHuntingAgentCount() > 0;
		if (bHunted)
		{
			mbPermaFail_DoWarning = false;
			mfPermaFail_HuntImmunityCount = 8.f;
		}
		else
		{
			if (mfPermaFail_HuntImmunityCount > 0.f)
				mfPermaFail_HuntImmunityCount -= afTimeStep;
		}
		
		///////////////
		// Give immunity when close to agents
		mfPermaFail_ClosestAgentDistTimer -= afTimeStep;
		if (mfPermaFail_ClosestAgentDistTimer < 0)
		{
			mfPermaFail_ClosestAgentDistTimer = cMath_RandRectf(0.2, 0.4);
			cVector3f vPlayerPos = Player_GetPosition();
			iLuxEntity@ pAgent = cLux_ID_Entity(Blackboard_GetClosestAgent(vPlayerPos));
			if (pAgent is null) mfPermaFail_ClosestAgentDist = -1;
			else mfPermaFail_ClosestAgentDist = cMath_Vector3Dist(pAgent.GetPosition(), vPlayerPos);
		}
		bool bTooCloseToAgent = mfPermaFail_ClosestAgentDist < 7.0f && mfPermaFail_ClosestAgentDist >= 0;
		if (bTooCloseToAgent) mfPermaFail_ClosestAgentImmunityTimer = 10;
		else mfPermaFail_ClosestAgentImmunityTimer = cMath_Max(0.0f, mfPermaFail_ClosestAgentImmunityTimer - afTimeStep);
				
		/////////////////
		// Start permafail?	
		bool bRateOK = mfRate >= 0.2f;
        bool bFearOK = mfLevel >= 1.0f && bRateOK;
        
        int lPlayerState = pPlayer.GetCurrentStateId();
		
        bool bPlayerStateOK = lPlayerState != ePlayerState_InteractiveCutsceneAnimation &&
							  lPlayerState != ePlayerState_InteractiveCameraAnimation &&
							  lPlayerState != ePlayerState_CutsceneAnimation &&
							  lPlayerState != ePlayerState_ClimbLedge && 
							  lPlayerState != ePlayerState_Ladder && 
							  lPlayerState != ePlayerState_Custom_Struggle &&
							  lPlayerState != ePlayerState_Custom_CheckBaby &&
							  lPlayerState != ePlayerState_Custom_ReadMemoryCylinder &&
							  lPlayerState != ePlayerState_Custom_Inventory &&
							  lPlayerState != ePlayerState_Custom_Thrown &&
							  lPlayerState != ePlayerState_Custom_Slide &&
							  lPlayerState != ePlayerState_ZoomArea &&
							  lPlayerState != ePlayerState_Dead;
        
		bool bConditionsOK = mbPermaFail_Enabled && 
							 mbPermaFail_Active == false && 
							 mfPermaFail_HuntImmunityCount <= 0.f && 
							 mfPermaFail_ClosestAgentImmunityTimer <= 0 &&
							 bPlayerStateOK && 
							 bFearOK;
		
		if (mfPermafail_AutoStopSoundLoopDelay >= 0.0f)
		{
			mfPermafail_AutoStopSoundLoopDelay -= afTimeStep;
			if (mfPermafail_AutoStopSoundLoopDelay < 0)
				mbPermafail_AutoStopSoundLoop = true;
		}
		
		if (mfPermafail_WarningFlashCount_RateDelay > 0)
			mfPermafail_WarningFlashCount_RateDelay -= afTimeStep;
		
		if (bConditionsOK == false)
		{
			if (mbPermafail_SoundLoopActive && mbPermafail_AutoStopSoundLoop)
			{
				StopStruggleSoundLoop(2.0f);
			}
			
			mfPermaFail_TriggerCount = 8.f;
			mbPermaFail_DoWarning = false;
			
			if (bRateOK==false)
				mfPermafail_WarningFlashCount_RateDelay = 5.0f;
				
			return;
		}
		
		/////////////////
		// Permafail allowed!
		mbPermaFail_DoWarning = true;
		
		mfPermaFail_TriggerCount -= afTimeStep;		
		
		if (mfPermaFail_TriggerCount < 5.0f && mbPermafail_SoundLoopActive==false)
		{
			PlayStruggleSoundLoop(3.0f, 0.3f, true);
		}
		
		if (mfPermaFail_TriggerCount <= 0.f && pPlayer.GetCharacterBody().IsOnGround())
		{			
			/////////////////
			// Start struggle if second chance!
			if (mbPermaFail_SecondChance && mlPermaFail_StruggleCount <= 0)
			{	
				++mlPermaFail_StruggleCount;
				
				tString sAnimLoop = "permafail_struggle1_high_loop";
				tString sAnimStruggle = "permafail_struggle1_low_loop";
				tString sAnimIntro = "permafail_struggle1_high_start";
				tString sAnimOutro = "permafail_struggle1_high_end";
				
				if (Player_GetCrouching())
				{
					sAnimLoop = "permafail_struggle1_high_crouch_loop";
					sAnimStruggle = "permafail_struggle1_low_crouch_loop";
					sAnimIntro = "permafail_struggle1_high_crouch_start";
					sAnimOutro = "permafail_struggle1_high_crouch_end";
				}
				
				mbPermafail_AutoStopSoundLoop = false;
				
				Player_ChangeStateToNormal();
				Struggle_SetIsPermaFailStruggle(true);
				Struggle_StartAnimation("", sAnimLoop, sAnimStruggle, sAnimIntro, sAnimOutro, true, "", "", "", "", 6.f, true, 2.f);
				
				FadeTentacleSizeAddTo(1.f, 1.f);
			}
			else
			{
				StartPermaFailIntro();
			}
			
			mbPermaFail_PlayedQuickWarningFlash = false;
			mfPermaFail_WarningFlashCount = 1.f;
		}
		else
		{
			/////////////////
			// Flashes!
			// TODO: StruggleFlashHandler should handle this, just set time interval!
			mfPermaFail_WarningFlashCount -= afTimeStep;
			if (mfPermaFail_WarningFlashCount <= 0.f && mfPermafail_WarningFlashCount_RateDelay <= 0.f)
			{
				StruggleFlashHandler_DoFlash(0, 0, false);
				
				mfPermaFail_WarningFlashCount = cMath_RandRectf(3.5f, 4.5f);
				
				if (mbPermaFail_PlayedQuickWarningFlash == false &&
					(cMath_RandRectl(0, 1) == 0 || mfPermaFail_TriggerCount < 4.f))
				{
					mbPermaFail_PlayedQuickWarningFlash = true;
					mfPermaFail_WarningFlashCount = cMath_RandRectf(0.4f, 0.6f);
				}					
			}
		}
	}
	
	//------------------------------------------------------------
	
	void PermaFailStruggle_Succeed()
	{
		StopStruggleSoundLoop(0.75f);
			
		FadeLevelTo(0.8f, 0.f, false);
				
		mlLevelRegenStep = 2;
		mbLevelRegenCapActive = true;
		
		FadeTentacleSizeAddTo(0.f, 1.f);
	}

	//----------------------------------------------------------------------------------------

	void PermaFailStruggle_Fail()
	{
		StartPermaFailIntro();		
	}
	
	//------------------------------------------------------------
	
	void SetPermaFailPlayVocals(bool abEnabled)
	{
		mbPermaFail_PlayVocals = abEnabled;
	}
		
	//------------------------------------------------------------
	
	void StopStruggleSoundLoop(float afFadeTime)
	{
		mbPermafail_AutoStopSoundLoop = true;
		mfPermafail_AutoStopSoundLoopDelay = -1.0f;
		
		if (Sound_GuiIsPlaying(gsStruggleLoopSound)==false) return;
		
		mbPermafail_SoundLoopActive = false;
		Sound_StopGui(gsStruggleLoopSound, afFadeTime);
	}
		
	//------------------------------------------------------------
	
	void PlayStruggleSoundLoop(float afFadeTime, float afVolume, bool abAutoStop)
	{
		mbPermafail_AutoStopSoundLoop = abAutoStop;
		mbPermafail_SoundLoopActive = true;
		mfPermafail_AutoStopSoundLoopDelay = -1.0f;
		
		if (Sound_GuiIsPlaying(gsStruggleLoopSound))
		{
			Sound_FadeGuiVolume(gsStruggleLoopSound, afVolume, afFadeTime);
			return;
		}
		
		Sound_FadeInGui(gsStruggleLoopSound, afVolume, afFadeTime);
	}
		
	//------------------------------------------------------------
	
	void SetStruggleSoundLoopAutoStop(float afDelay)
	{
		if (afDelay == 0)
		{
			mbPermafail_AutoStopSoundLoop = true;
			mfPermafail_AutoStopSoundLoopDelay = -1.0f;
			return;
		}
		
		mfPermafail_AutoStopSoundLoopDelay = afDelay;
	}
		
	//------------------------------------------------------------
	
	void StartPermaFailIntro(bool abPlaySounds = true)
	{		
		mbPermaFail_Active = true;
		mfPermaFail_IntroCount = 0.f;
		mlPermaFail_IntroStage = 0;
		
		msPermafail_Source = "";
		
		FadeLevelTo(1.f, 1.f);
		SetForcedAddFearRate(eFearForcedRateType_PermaFail, 1.f, 8.f, false);
		
		Item_PutAway(eItemHandlerHand_Left);
		Item_PutAway(eItemHandlerHand_Right);
		
		GhoulProgression_FadeCustomArmMaterial(GhoulProgression_GetPermafailFadeProgression(), 1.0f);
		PlayStruggleSoundLoop(3.0f, 0.75f, false);
		
		Hint_SetCanShowHints(false);
		Pregnancy_SetBarksActive(false);
		
		if (abPlaySounds)
		{
			Sound_PlayGui("player/foley/damage/player_permafail", 1.0f, eSoundEntryType_GuiWorld);
			if (mbPermaFail_PlayVocals)
			{
				Voice_Play("Global_AboutToPermafail");
			}
			//Sound_CreateAtEntity("Sound_PermaFail","player/vocalisations/temp/ghoul_trasform", "player", 1.0f);
		}
		
		////////////////
		// Send message to agents
		array<iLuxEntity@> vAgents;
		cLux_GetCurrentMap().GetEntityArray("*", eLuxEntityType_Agent, "", vAgents);
		for (uint i = 0; i < vAgents.size(); i++)
			vAgents[i].BroadcastMessage(eLuxEntityMessage_PlayerDead, null, cVector3f(0), 0);
	}
	
	//------------------------------------------------------------
	
	int GetTotalTimesPermafailed()
	{
		return mlPermaFail_TotalTimesTriggered;
	}
	
	//------------------------------------------------------- 
	
	//NOTE: Only to be used by the debug menu
	void _Global_TriggerPermaFail()
	{
		TriggerPermaFail(true);
	}
	
	//------------------------------------------------------- 
	
	void TriggerPermaFail(bool abDoIntro = false, const tString &in asSource = "", bool abPlaySkippedIntroSound = false)
	{	
		////////////////
		// Intro?
		if (abDoIntro)
		{
			StartPermaFailIntro();
			msPermafail_Source = asSource;
		}
		////////////////
		// Skip to end of intro!
		else
		{
			StartPermaFailIntro(false);
			mlPermaFail_IntroStage = 2;
			msPermafail_Source = asSource;
			
			if (abPlaySkippedIntroSound)
				Sound_PlayGui("player/foley/damage/player_death", 1.f, eSoundEntryType_Gui);
		}
		
		mlPermaFail_TotalTimesTriggered++;
		mbPermaFail_TriggerWhenInNormalState = false;
	}
	
	//------------------------------------------------------------
	
	void TriggerPermaFail_Fall()
	{
		StartPermaFailIntro(false);
		mlPermaFail_IntroStage = 2;
		msPermafail_Source = "fall";
			
		Sound_PlayGui("new_sounds/player/player_fall_death", 1.f, eSoundEntryType_Gui);
		Sound_PlayGui("player/UI/permafail/permafail_stinger", 0.7f, eSoundEntryType_Gui);
		
		mlPermaFail_TotalTimesTriggered++;
		mbPermaFail_TriggerWhenInNormalState = false;
		mbPermafail_FastFadeOut = true;
	}
	
	//------------------------------------------------------------
	
	void StartPermaFail(const tString &in asSource)
	{
		mfDarknessMaxFactor = gfDarknessMaxFactor_PostPF;
		
		msPermafail_Source = "";
		
		mlPermaFail_PrevGhoulLevel = GhoulProgression_GetProgression();
		GhoulProgression_Increase(false, false); // Increase, but don't do effects yet!
		mlPermaFail_StruggleCount = 0;
		
		/////////////////////
		// Set up vars
		iCharacterBody@ pCharBody = cLux_GetPlayer().GetCharacterBody();
		
		mbPermaFail_Active = true;
		mbPermaFail_SecondChance = true;
		mbPaused = true;
		mfRate = 0;
		
		++mlPermaFail_PermaFailCount;
		
		/////////////////////
		// Set up player
		SetForcedAddFearRate(eFearForcedRateType_PermaFail, 0.f, 0.f, false);		
		
		PlayerBody_SetActive(true);
		cLux_GetPlayer().SetActive(true);
		pCharBody.StopMovement();
		
		Item_PutAway(eItemHandlerHand_Left);
		Item_PutAway(eItemHandlerHand_Right);
		
		/////////////////////
		// Call map callback
		bool bDefault = true;
		cLuxMap@ pMap = cLux_GetCurrentMap();
		
		tString sMethodName = "bool OnPermaFail(const tString&in)";
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			tString sTempSource = asSource;
			pMap.SetArgString(0, sTempSource);
			pMap.ScriptExecute(); 
			bDefault = pMap.GetReturnBool();
		}
		else
		{
			sMethodName = "bool OnPermaFail()";
			if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
			{
				pMap.ScriptExecute(); 
				bDefault = pMap.GetReturnBool();
			}
		}
		
		/////////////////////
		// Not default permafail?
		if (bDefault == false)
		{			
			GhoulProgression_DoEffects(); // Do effects!
			
			FadeTentacleSizeAddTo(0.f, 0.1f);
			mfTentacleCriticalMulGoal = 1.f;
			
			FadeLevelTo(0.f, 0.f, true);
			mbPaused = false;
			mbPermaFail_Active = false;			
			
			Pregnancy_SetBarksActive(true);
			Player_ShowCrossHairIcons(true);
			Player_SetMoveSpeedMul(1.f, ePlayerMoveSpeedMulType_Fear);
			Player_SetLookSpeedMul(1.f);
			
			GhoulProgression_FadeCustomArmMaterial(GhoulProgression_GetProgression(), 1.0f);
			
			if (mbPermaFail_VolumeResetOnCustomPermaFail)
				Sound_FadeGlobalVolume(1.f, 0.5f, eSoundEntryType_WorldAll);
			
			mbPermaFail_VolumeResetOnCustomPermaFail = true;
			return;
		}
		
		Player_SetActive(false);
		Player_ShowCrossHairIcons(false);
		Player_SetMoveSpeedMul(0.f, ePlayerMoveSpeedMulType_Fear);
		Player_SetLookSpeedMul(0.1f);
		
		cLux_SetLookAtCallbacksActive(false);
		cLux_GetPlayer().SetCollideCallbacksActive(false);
		
		FadeLevelTo(1.f, 0.f, true);
		
		/////////////////////
		// Any scenes to play?
		if (mvPermaFail_Scenes.size() > 0)
		{
			mfTentacleCriticalMulGoal = 2.f;
			
			mlPermaFail_SceneId = 0;
			mfPermaFail_ExtraSceneDelay = 0.f;
			mbPermaFail_ScenesActive = true;
			
			cLux_AddDebugMessage("Shake start");
			if (mlPermaFail_FOVShakeID > -1)
				Effect_FOV_Shake_FadeOut(mlPermaFail_FOVShakeID, 0);
			mlPermaFail_FOVShakeID = Effect_FOV_Shake_Start(0.05, -1, 0, 0, 0, true, 0.4f, 2.0f, false);
			
			SetForcedAddFearRate(eFearForcedRateType_PermaFail, 0.f, 0.f, false);
						
			Sound_FadeGlobalVolume(0.f, 0.5f, eSoundEntryType_WorldAll);
			Sound_PlayGui("player/UI/permafail/permafail_riser", 1.f);
			Sound_FadeInGui("player/UI/permafail/permafail_loop", 0.2f, 3.f);

			Player_SetForceNightVision(true);
			Pregnancy_SetBarksActive(false);
			
			StruggleFlashHandler_DoFlash(0.1f, 0.25f);
			StruggleFlashHandler_DoFlash(0.1f, 0.8f);
			StruggleFlashHandler_DoFlash(0.1f, 1.6f);
			
			mfVfx_ForcePulseOutCount = 2.1f;
			mBaseObj.Timer_Add("Timer_PermaFailScene_Prepare", 2.f, "OnTimer_PermaFailScene_Prepare");
			return;
		}
		
		/////////////////////
		// No scenes to play, start wake up sequence!
		if (mbPermafail_BabyMomentEnabled)
		{
			StartPermaFailBabySequence(2.85);
		}
		else
		{
			SetupPermaFailWakeUpSequence();
			StartPermaFailWakeUpSequence(3.75);
		}
	}
	
	//------------------------------------------------------------
	
	///////////////////////////
	// Permafail scenes	
	void OnTimer_PermaFailScene_Prepare(uint64 alId)
	{
		/////////////////////
		// Map callback
		if (mlPermaFail_SceneId > 0)
		{
			tString sMethodName = "void OnPermaFailSceneEnded()";
			cLuxMap@ pMap = cLux_GetCurrentMap();
			if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
				pMap.ScriptExecute();
		}
		
		///////////////////
		// Setup player
		cLuxPlayer@ pPlayer = cLux_GetPlayer();
		iCharacterBody@ pCharBody = pPlayer.GetCharacterBody();
		
		pPlayer.StopCameraRotate(0.1);
		pPlayer.StopAutomoveCharBody();
		pPlayer.SetActive(false);
		pCharBody.SetActive(false);
		pCharBody.SetCustomGravityActive(false);
		
		CameraAnimation_End();
		
		///////////////////
		// Setup effects
		Effect_ImageTrail_Clear();
		
		///////////////////////////
		// No more scenes, do default reset!
		if (mlPermaFail_SceneId > int(mvPermaFail_Scenes.size()) - 1 || 
			mlPermaFail_PermaFailCount > 1 && mlPermaFail_SceneId > 0) // Only play first scene when permafailing multiple times in same area
		{
			mbPermaFail_PlayGhoulBreathing = true;
			mbPermaFail_ScenesActive = false;
			mvPermaFail_Scenes.resize(0);
			
			Effect_FOV_Shake_FadeOut(mlPermaFail_FOVShakeID, 0);
			
			Sound_StopGui("player/UI/permafail/permafail_ghoul_breathing", 1.f);
			Sound_StopGui("player/UI/permafail/sequence/corridor_loop", 1.5f);
			
			Player_SetForceNightVision(false);
			Pregnancy_SetBarksActive(true);
			
			if (mbPermafail_BabyMomentEnabled)
				mBaseObj.Timer_Add("Timer_Baby_Setup", 2.1f, "Timer_Baby_Setup");
			else
				StartPermaFailWakeUpSequence(4.0f);
			return;
		}
		
		////////////////
		// Prepare next scene!
		cPermaFailScene@ pScene = mvPermaFail_Scenes[mlPermaFail_SceneId];
		
		if (mlPermaFail_SceneId > 0)
		{
			cPermaFailScene@ pPrevScene = mvPermaFail_Scenes[mlPermaFail_SceneId - 1];
			if (pPrevScene.msPlayerAnim != "")
				PlayerBody_StopAnimation(pPrevScene.msPlayerAnim, 0.f);
			if (pPrevScene.msCameraAnim != "")
				CameraAnimation_End();
		}			
		
		
		Player_ChangeStateToNormal();
		
		///////////////////////
		// Position player!
		float fTime = mlPermaFail_SceneId == 0 ? 0.5f : gfPermaFailSceneDelay / 2.f;
		fTime += mfPermaFail_ExtraSceneDelay / 2.f;
		
		mBaseObj.Timer_Add("Timer_PermaFailScene_PositionPlayer", fTime, "OnTimer_PermaFailScene_PositionPlayer");
		
		///////////////////////
		// Sync tentacles
		float fDuration = pScene.mfDuration - 0.25f;
		float fMod = cMath_Modulus(fDuration, gfPermaFailTentaclePulseRate);
		float fPulseCount = fDuration / gfPermaFailTentaclePulseRate;
		
		mfVfx_ForcePulseOutCount = fTime * 2.f - (gfPermaFailTentaclePulseRate - fMod - 0.15f);
		
		if (cMath_FloorToInt(fPulseCount) % 2 == 1)
			mfVfx_ForcePulseOutCount -= gfPermaFailTentaclePulseRate;	
		
		/////////////////////
		// Map callback
		tString sMethodName = "void OnPermaFailScenePrepared()";
		cLuxMap@ pMap = cLux_GetCurrentMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
			pMap.ScriptExecute();
	}
		
	//------------------------------------------------------------
	
	// TODO: Fix so we can set position/orientation the same frame as ending a cutscene and merge this func with "OnTimer_PermaFailScene_Prepare".
	void OnTimer_PermaFailScene_PositionPlayer(uint64 alId)
	{
		cPermaFailScene@ pScene = mvPermaFail_Scenes[mlPermaFail_SceneId];
		
		Player_PlaceAtEntity(pScene.msEntity, true, true);
		Player_SetCrouching(pScene.mbCrouch, true, true);
		
		if (pScene.mlType == ePermaFailSceneType_PlayerMove)
		{
			cLuxPlayer@ pPlayer = cLux_GetPlayer();
			
			cVector3f vDir = pScene.mvMoveEnd - pScene.mvMoveStart;
			float fYaw = cMath_GetAngleFromPoints3D(0.f, vDir).y;	
			
			pPlayer.GetCharacterBody().SetYaw(fYaw);
			PlayerBody_ResetYaw();	
			
			if (pScene.mbRandomLookDirActive)
				pPlayer.GetCamera().SetPitch(cMath_ToRad(cMath_RandRectf(-10.f, -5.f)));
		}
		else if (pScene.mlType == ePermaFailSceneType_PlayerAnim)
		{
			if (pScene.msPlayerAnim != "") // Start anim with 0 speed so player is positioned correctly
				PlayerBody_PlayCutsceneAtEntity(pScene.msPlayerAnim, pScene.msEntity, false, 0.f, "", 0.f);
		}
		
		////////////////
		// Start next scene!
		float fTime = mlPermaFail_SceneId == 0 ? 0.5f : gfPermaFailSceneDelay / 2.f;
		fTime += mfPermaFail_ExtraSceneDelay / 2.f;
		
		mBaseObj.Timer_Add("Timer_PermaFailScene_Start", fTime, "OnTimer_PermaFailScene_Start");
	}
	
	//------------------------------------------------------------
	
	void OnTimer_PermaFailScene_Start(uint64 alId)
	{
		/////////////////////////
		// Fade in
		Effect_Fade_In(0.25f);
		FadeTentacleSizeAddTo(0.f, 0.75f);
		
		/////////////////////////
		// Setup vars
		cPermaFailScene@ pScene = mvPermaFail_Scenes[mlPermaFail_SceneId];
		cLuxPlayer@ pPlayer = cLux_GetPlayer();
		iCharacterBody@ pCharBody = pPlayer.GetCharacterBody();		
		
		/////////////////////////
		// Setup scene
		pPlayer.ChangeState(ePlayerState_Custom_PermaFail);
		pPlayer.SetActive(true);
		pCharBody.SetActive(true);
		
		if (pScene.mlType == ePermaFailSceneType_PlayerMove)
		{
			// Extra strong gravity to keep player on the ground
			pCharBody.SetCustomGravity(cVector3f(0.f, -20.f, 0.f));
			pCharBody.SetCustomGravityActive(true);
			
			pPlayer.AutomoveCharBodyTo(10000.f, 1.f, pScene.mfMoveSpeed, pScene.mvMoveEnd);
			
			PlayerBody_SetAnimationSet("permafail");
			
			Sound_PlayGui("player/UI/permafail/sequence/corridor_loop", 1.f, eSoundEntryType_Gui);
		}
		else if (pScene.mlType == ePermaFailSceneType_PlayerAnim)
		{
			if (pScene.msPlayerAnim != "")
				PlayerBody_PlayCutsceneAtEntity(pScene.msPlayerAnim, pScene.msEntity, false, 0.f);
			if (pScene.msAnimEntity != "")
				Entity_PlayAnimation(pScene.msAnimEntity, pScene.msEntityAnim, 0.f, false, false);
		}
		else if (pScene.mlType == ePermaFailSceneType_CameraAnim)
		{
			CameraAnimation_Begin(pScene.msCameraAnim,"",false);
		}
		
		/////////////////////////
		// Effects!				
		mbPermaFail_RandCamRot = pScene.mbRandomLookDirActive;
		
		Effect_ImageTrail_Start(2.f, 0.01f, pScene.mfDuration, 0.01f);
		
		Sound_FadeGlobalVolume(1.f, 0.1f, eSoundEntryType_WorldAll);
		Sound_PlayGui("player/UI/permafail/permafail_stinger", 0.7f, eSoundEntryType_Gui);
		
		if (mlPermaFail_SceneId == 0 && mbPermaFail_PlayGhoulBreathing)
			Sound_PlayGui("player/UI/permafail/permafail_ghoul_breathing", 1.f, eSoundEntryType_Gui);
		else
			Sound_FadeGuiVolume("player/UI/permafail/permafail_ghoul_breathing", 1.f, 0.3f);
		
		/////////////////////
		// Call map callback
		tString sMethodName = "void OnPermaFailSceneStarted()";
		cLuxMap@ pMap = cLux_GetCurrentMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
			pMap.ScriptExecute();
		
		///////////////////////////
		// Prepare ending scene
		mBaseObj.Timer_Add("Timer_PermaFailScene_FadeOut", pScene.mfDuration - 0.25f, "OnTimer_PermaFailScene_FadeOut");
		mBaseObj.Timer_Add("Timer_PermaFailScene_End", pScene.mfDuration, "OnTimer_PermaFailScene_End");
	}
	
	//------------------------------------------------------------
	
	void OnTimer_PermaFailScene_FadeOut(uint64 alId)
	{
		FadeTentacleSizeAddTo(25.f, 0.5f);
		
		Sound_FadeGuiVolume("player/UI/permafail/permafail_ghoul_breathing", 0.f, 0.3f);
		Sound_PlayGui("player/UI/permafail/sequence/corridor_stop", 1.f, eSoundEntryType_Gui);
		Sound_StopGui("player/UI/permafail/sequence/corridor_loop", 1.5f);
		
		Sound_FadeGlobalVolume(0.f, 0.3f, eSoundEntryType_WorldAll);
	}
		
	//------------------------------------------------------------

	void OnTimer_PermaFailScene_End(uint64 alId)
	{
		///////////////////////////
		// End scene
		cPermaFailScene@ pScene = mvPermaFail_Scenes[mlPermaFail_SceneId];
		
		Effect_Fade_Out(0.1f);
		mfPermaFail_ExtraSceneDelay = cMath_RandRectf(0.f, 1.f);
		
		cLux_GetPlayer().StopAutomoveCharBody();
		
		///////////////////////////
		// Effects
		mbPermaFail_RandCamRot = false;	

		/////////////////////////
		// Flashes!		
		bool bDoFlash = mlPermaFail_SceneId != int(mvPermaFail_Scenes.size()) - 1;
		if (bDoFlash)
		{
			float fTotalTime = gfPermaFailSceneDelay + mfPermaFail_ExtraSceneDelay - 1.f;
			
			array<float> vSlots;
			vSlots.resize(int(fTotalTime / 0.3f));
			
			for (uint i = 0; i < vSlots.size(); ++i)
				vSlots[i] = 0.3f + 0.3f * i;
			
			int lMinFlashes = 2;
			int lMaxFlashes = mfPermaFail_ExtraSceneDelay > 0.5f ? 4 : 3;
			int lFlashNum = cMath_RandRectl(lMinFlashes, lMaxFlashes);
			
			for (int i = 0; i < lFlashNum; ++i)
			{
				int lSlotId = cMath_RandRectl(0, vSlots.size() - 1);
				StruggleFlashHandler_DoFlash(0.1f, vSlots[lSlotId]);
				
				vSlots.removeAt(lSlotId);
				
				if (i == 0)
					vSlots.removeAt(i % vSlots.size());
			}
		}
		
		///////////////////////////
		// Prepare next scene
		mlPermaFail_SceneId++;
		mBaseObj.Timer_Add("Timer_PermaFailScene_Prepare", 0.1f, "OnTimer_PermaFailScene_Prepare");
		
		PlayerBody_SetAnimationSet("");
	}
	
	//------------------------------------------------------------	
	
	void StartPermaFailBabySequence(float afDelay)
	{
		Effect_Fade_Out(0.1f);
		
		cLux_GetPlayer().SetActive(false);
		cLux_GetPlayer().GetCharacterBody().SetActive(false);
		
		Sound_FadeGlobalVolume(0.f, 0.5f, eSoundEntryType_WorldAll);
		
		Sound_PlayGui("player/UI/permafail/permafail_riser", 1.f);
		Sound_FadeInGui("player/UI/permafail/permafail_loop", 0.2f, 3.f);
		
		mBaseObj.Timer_Add("Timer_Baby_Setup", afDelay, "Timer_Baby_Setup");
	}
	
	//------------------------------------------------------------	
	
	void Timer_Baby_Setup(uint64 alId)
	{
		mbPermaFail_BabyMomentActive = true;
		
		PlayerBody_SetActive(false);
		cLux_GetPlayer().SetCameraPosAdd(eCameraAddType_Permafail, cVector3f_Up*1000);
		
		cWorld @pWorld = cLux_GetCurrentMap().GetWorld();
		mbPermafail_SkyboxActive = pWorld.GetSkyBoxActive();
		pWorld.SetSkyBoxActive(false);
		mbPermafail_DirLightActive = pWorld.GetDirectionalLightActive();
		pWorld.SetDirectionalLightActive(false);
		mbPermafail_FogActive = pWorld.GetFogActive();
		pWorld.SetFogActive(false);
		mbPermafail_SecondaryFogActive = pWorld.GetSecondaryFogActive();
		pWorld.SetSecondaryFogActive(false);
		
		Sound_FadeGlobalVolume(1.f, 0.1f, eSoundEntryType_WorldAll);
		Sound_PlayGui("player/UI/permafail/sequence/baby_loop", 1);
		
		mbPermafail_RestoreVertigo = Player_GetVertigoActive();
		Player_SetVertigoActive(false);
		
		mBaseObj.Timer_Add("Timer_Baby_Start", 1.0f, "Timer_Baby_Start");
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_Start(uint64 alId)
	{
		cCamera@ pCam = cLux_GetPlayer().GetCamera();
		cMatrixf mtxPos = pCam.GetMatrix();
		mtxPos.SetTranslation(pCam.GetPosition()+pCam.GetForward()*2.f);
		
		ePregStage state = Pregnancy_GetStage();
		cLux_GetCurrentMap().CreateEntity("FearHandler_PF_Baby", gvPermafailBabyEnts[state], mtxPos, 1);
		cLuxProp@ pProp = cast<cLuxProp>(cLux_GetCurrentMap().GetLatestEntity());
		pProp.SetRenderLayer(2);
		
		Effect_Fade_In(0.3f);
		Effect_ImageTrail_Clear();
		
		if (state != ePregStage_Unknown)
			Sound_PlayGui("player/baby/heartbeat", 1);

		
		SetActive(false);
		Effect_FearTentacles_Start();
		Effect_FearTentacles_SetRingModeActive(true);
		
		float fBabyCoverage = GetBabyCoverageForLevel(float(mlPermaFail_PrevGhoulLevel));
		Effect_FearTentacles_SetCoverage(fBabyCoverage);
		Effect_FearTentacles_SetScaleAdd(0);
		Effect_FearTentacles_SetSpeedMul(0.1);
		Effect_FearTentacles_SetVignetteEnabled(false);
		
		//float fScreenEffectSizeMul = 1.0f + (1.0f-fTentacleMul)*0.4f;
		//mvPermafail_ScreenEffectIDs[0] = Effect_Screen_Start("_temp_tentacle_vignette.mat", cVector2f(0.5f, 0.5f), cVector2f(1.3, 0.75)*fScreenEffectSizeMul, 1, 0, 999999, 0);

		if (mlPermaFail_BlurId > -1) Effect_Blur_FadeOut(mlPermaFail_BlurId, 1);
		mlPermaFail_BlurId = Effect_Blur_Start(1, 0);
		
		mBaseObj.Timer_Add("Timer_Baby_BlurPulse_On", 0.5, "Timer_Baby_BlurPulse");
		mBaseObj.Timer_Add("Timer_Baby_CameraSway", 0.1, "Timer_Baby_CameraSway");
		mBaseObj.Timer_Add("Timer_Baby_Tentacles", 2, "Timer_Baby_Tentacles");
		mBaseObj.Timer_Add("Timer_Baby_End", 6, "Timer_Baby_End");
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_BlurPulse(uint64 alId)
	{
		float fTarget = 1.0f;
		float fSpeedFactor = cMath_RandRectf(0.75f, 1.25f);
		if (alId == H64("Timer_Baby_BlurPulse_On"))
		{
			fTarget = 1.75f;
			mBaseObj.Timer_Add("Timer_Baby_BlurPulse_Off", 1.0*fSpeedFactor, "Timer_Baby_BlurPulse");
		}
		else
		{
			fTarget = 0.85f;
			mBaseObj.Timer_Add("Timer_Baby_BlurPulse_On", 1.0*fSpeedFactor, "Timer_Baby_BlurPulse");
		}
		Effect_Blur_FadeAmount(mlPermaFail_BlurId, fTarget, 0.8f*fSpeedFactor);
		
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_CameraSway(uint64 alId)
	{
		mvPermafail_BabyMomentCamTarget = cMath_RandRectVector3f(cVector3f(-1, -1, 0) ,cVector3f(1, 1, 0))*0.03f;
		mBaseObj.Timer_Add("Timer_Baby_CameraSway", cMath_RandRectf(0.75, 1.5), "Timer_Baby_CameraSway");
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_Tentacles(uint64 alId)
	{
		Effect_FearTentacles_FadeCoverage(GetBabyCoverageForLevel(float(GhoulProgression_GetProgression()+2)), 3, false);
		
		mlPermafail_mlTentaclePulsesLeft = 2;
		Timer_Baby_TentaclesFocus(0);
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_TentaclesUnfocus(uint64 alId)
	{
		mlPermafail_mlTentaclePulsesLeft--;
		Effect_FearTentacles_FadeMaterial(eFearTentacleMaterial_Default, 0.6);
		
		if (mlPermafail_mlTentaclePulsesLeft > 0)
			mBaseObj.Timer_Add("Timer_Baby_TentaclesFocus", 0.8, "Timer_Baby_TentaclesFocus");
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_TentaclesFocus(uint64 alId)
	{
		Effect_FearTentacles_FadeMaterial(eFearTentacleMaterial_Focus, 0.6);
		mBaseObj.Timer_Add("Timer_Baby_TentaclesUnfocus", 0.6, "Timer_Baby_TentaclesUnfocus");
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_End(uint64 alId)
	{
		Effect_Fade_Out(0.5f);
		Sound_PlayGui("player/UI/permafail/sequence/baby_stop", 1);
		Sound_StopGui("player/UI/permafail/sequence/baby_loop", 0.75f);
		Sound_StopGui("player/baby/heartbeat", 0.75f);
		mBaseObj.Timer_Add("Timer_Baby_Cleanup", 0.5, "Timer_Baby_Cleanup");
		
		StartPermaFailWakeUpSequence(2.625); // Starting here to allow sounds to play with the correct delay
	}
	
	//------------------------------------------------------------
	
	float GetBabyCoverageForLevel(float afLevel)
	{
		float fTentacleMul = cMath_Clamp(afLevel/16, 0.0f, 1.0f);
		cLux_AddDebugMessage("Coverage: "+fTentacleMul);
		return fTentacleMul;
	}
	
	//------------------------------------------------------------
	
	void Timer_Baby_Cleanup(uint64 alId)
	{
		mbPermaFail_BabyMomentActive = false;
		PlayerBody_SetActive(true);
		
		Entity_Destroy("FearHandler_PF_Baby");
		Effect_Blur_Reset();
		mBaseObj.Timer_Remove("Timer_Baby_BlurPulse_Off");
		mBaseObj.Timer_Remove("Timer_Baby_BlurPulse_On");
		mBaseObj.Timer_Remove("Timer_Baby_CameraSway");
		cLux_GetPlayer().SetCameraPosAdd(eCameraAddType_Permafail, 0);
		cLux_GetPlayer().SetCameraPosAdd(eCameraAddType_Permafail_Add, 0);
		
		cWorld @pWorld = cLux_GetCurrentMap().GetWorld();
		pWorld.SetSkyBoxActive(mbPermafail_SkyboxActive);
		pWorld.SetDirectionalLightActive(mbPermafail_DirLightActive);
		pWorld.SetFogActive(mbPermafail_FogActive);
		pWorld.SetSecondaryFogActive(mbPermafail_SecondaryFogActive);
		
		Effect_FearTentacles_SetRingModeActive(false);
		Effect_FearTentacles_Stop();
		SetActive(true);
		Effect_FearTentacles_SetMaterial(eFearTentacleMaterial_Default);
		
		Effect_Screen_FadeOut(mvPermafail_ScreenEffectIDs[0], 0);
		Effect_Screen_FadeOut(mvPermafail_ScreenEffectIDs[1], 0);
		mvPermafail_ScreenEffectIDs[0] = -1;
		mvPermafail_ScreenEffectIDs[1] = -1;
		
		Player_SetVertigoActive(mbPermafail_RestoreVertigo);
		
		SetupPermaFailWakeUpSequence();
	}
	
	//------------------------------------------------------------	
	
	void SetupPermaFailWakeUpSequence()
	{
		cLux_GetPlayer().SetActive(false);
		cLux_GetPlayer().GetCharacterBody().SetActive(false);
		
		if (mbPermafail_BabyMomentEnabled == false)
		{
			Sound_PlayGui("player/UI/permafail/permafail_riser", 1.f);
			Sound_FadeInGui("player/UI/permafail/permafail_loop", 0.2f, 3.f);
			cLux_AddDebugMessage("Reset? "+mbPermafail_BabyMomentEnabled_AutoReset);
		}
				
		Effect_Fade_Out(0.1f);
		
		Sound_FadeGlobalVolume(0.f, 0.5f, eSoundEntryType_WorldAll);
	}
	
	//------------------------------------------------------------
	
	///////////////////////////
	// Default wake up
	void StartPermaFailWakeUpSequence(float afDelay)
	{
		float fSoundDelay = cMath_Max(afDelay-2.625f, 0.0f);
		mBaseObj.Timer_Add("Timer_WakeUp_StopLoop", fSoundDelay, "OnTimer_WakeUp_Sound");
		fSoundDelay = cMath_Max(afDelay-2.3f, 0.0f);
		mBaseObj.Timer_Add("Timer_WakeUp_PlaySound", fSoundDelay, "OnTimer_WakeUp_Sound");
		
		mBaseObj.Timer_Add("Timer_WakeUp_Setup", afDelay, "OnTimer_WakeUp_Setup");
	}

	//------------------------------------------------------------

	void OnTimer_WakeUp_Sound(uint64 alID)
	{
		if (alID == H64("Timer_WakeUp_StopLoop"))
		{
			Sound_StopGui("player/UI/permafail/permafail_loop", 1.f);
		}
		else
		{
			if (mbPermafail_WakeUpSoundsAllowed)
				Sound_PlayGui("player/UI/permafail/player_permafail_end", 1.f, eSoundEntryType_Gui);
		}
	}

	//------------------------------------------------------------
	
	void OnTimer_WakeUp_Setup(uint64 alId)
	{
		if (mbPermafail_BabyMomentEnabled_AutoReset)
				mbPermafail_BabyMomentEnabled = false;
				
		/////////////////////////////
		// Map callback
		bool bDefaultWakeUp = true;
		tString sMethod = "bool OnPermaFailRespawn()";
		cLuxMap@ pMap = cLux_GetCurrentMap();		
		
		if (pMap.ScriptMethodExists(sMethod) && pMap.ScriptPrepare(sMethod))
		{
			pMap.ScriptExecute(); 
			bDefaultWakeUp = pMap.GetReturnBool();
		}
		
		/////////////////////////////
		// Agent callback
		for (uint i = 0; i < mvThreatAgents.size(); ++i)
		{
			cFearThreatAgent@ pAgent = mvThreatAgents[i];
			if (pAgent is null) continue;
			cScript_RunGlobalFunc(pAgent.GetEntityName(), "", "_Global_OnPermafailRespawn");
		}
		
		///////////////////////////
		// Custom wake up, escape!
		if (bDefaultWakeUp == false)
		{
			if (mbPermaFail_VolumeResetOnCustomPermaFail)
				Sound_FadeGlobalVolume(1.f, 1.f, eSoundEntryType_WorldAll);
			
			mbPermaFail_VolumeResetOnCustomPermaFail = true;
			
			Player_ShowCrossHairIcons(true);
			
			cLux_GetPlayer().SetActive(true);
			cLux_GetPlayer().ChangeState(ePlayerState_Normal);
			cLux_GetPlayer().GetCharacterBody().SetActive(true);
			
			cLux_SetLookAtCallbacksActive(true);
			cLux_GetPlayer().SetCollideCallbacksActive(true);
			Hint_SetCanShowHints(true);
			
			Player_SetMoveSpeedMul(1.f, ePlayerMoveSpeedMulType_Fear);
			Player_SetLookSpeedMul(1.f);
			
			mbPaused = false;
			mbPermaFail_Active = false;
			
			FadeLevelTo(0.f, 2.f, true);
			FadeTentacleSizeAddTo(0.f, 0.1f);
			return;
		}
		
		//////////////////////////////
		// Get wake up area
		// (The one least used if more than one available)
		array<iLuxEntity@> vAreas;
		cLux_GetCurrentMap().GetEntityArray(msPermaFail_WakeUpArea, eLuxEntityType_Area, "cScrAreaPermaFail", vAreas);	
		
		if (vAreas.size() > 0)
		{
			int lLowestUseCount = -1;
			iLuxEntity@ pLeastUsedArea = null;
			
			for (uint i = 0; i < vAreas.size(); ++i)
			{				
				iLuxEntity@ pArea = vAreas[i];
				
				int lUseCount = pArea.GetVarInt("PermaFailUseCount");
				if (lUseCount < lLowestUseCount || lLowestUseCount == -1)
				{
					lLowestUseCount = lUseCount;
					@pLeastUsedArea = pArea;
				}
			}
				
			msPermaFail_WakeUpArea = pLeastUsedArea.GetName();
			pLeastUsedArea.SetVarInt("PermaFailUseCount", ++lLowestUseCount);
		}
		
		/////////////////////////////
		// Set up player		
		cLux_GetPlayer().SetActive(true);
		cLux_GetPlayer().GetCharacterBody().SetActive(true);
		
		Player_SetMoveSpeedMul(0.f, ePlayerMoveSpeedMulType_Fear);
		Player_SetLookSpeedMul(1.f);
		
		bool bCrouching = false;
		if (msPermaFail_WakeUpArea != "")
		{
			Player_PlaceAtEntity(msPermaFail_WakeUpArea, true, true);
			cLux_AddDebugMessage("[FearHandler] Player respawned at "+msPermaFail_WakeUpArea);
			
			// Should the player crouch?
			cScript_RunGlobalFunc(msPermaFail_WakeUpArea, "cScrAreaPermaFail", "_Global_GetCrouch");
			bCrouching = cScript_GetGlobalReturnBool();
		}
		
		//////////////////////////////
		// Get wake up anim
		if (msPermaFail_WakeUpArea != "")
		{
			cScript_RunGlobalFunc(msPermaFail_WakeUpArea, "cScrAreaPermaFail", "_Global_GetWakeUpAnim");
			msPermaFail_WakeUpAnim = cScript_GetGlobalReturnString();
		}
		
		// Get default anim if specified one doesn't exist!
		iLuxEntity@ pPlayerBody = cLux_GetCurrentMap().GetEntityByName(PlayerBody_GetEntityName());
		bool bDoDefaultWakeUpAnim = pPlayerBody.GetMeshEntity().GetAnimationStateFromName(msPermaFail_WakeUpAnim) is null ||
								    cString_Sub(msPermaFail_WakeUpAnim, 0, 22) != "wake_up_from_permafail";
		
		if (bDoDefaultWakeUpAnim)
		{
			msPermaFail_WakeUpAnim = PlayerBody_GetRandomPermafailWakeUpAnim(!bCrouching);
		}
		
		/////////////////////////////
		// Set up anim
		if(msPermaFail_WakeUpArea != "")
		{
			cLuxArea@ pArea = cLux_ToArea(cLux_GetCurrentMap().GetEntityByName(msPermaFail_WakeUpArea));
			cVector3f vOffset = cVector3f(0.f, pArea.GetAreaBody().GetBoundingVolume().GetSize().y * -0.5f, 0.f);
			PlayerBody_PlayCutsceneAtEntity(msPermaFail_WakeUpAnim, msPermaFail_WakeUpArea, false, 0.f, "OnPermaFail_WakeUpAnimOver", 0.f, 0.f, vOffset);
		}
		else
		{
			PlayerBody_PlayCutsceneAnimation(msPermaFail_WakeUpAnim, false, 0.f, "OnPermaFail_WakeUpAnimOver", 0.f, 0.f);
		}
		
		PlayerBody_SetCutsceneMaxPitch(10.f);
		PlayerBody_SetCutsceneMaxYaw(10.f);
		
		// Set crouching after cutscene starts, so player is positioned correctly
		Player_SetCrouching(bCrouching, true, true);
		
		//////////////////////////////
		// Do wake up effects
		FadeTentacleSizeAddTo(25.f, 0.1f);
		mfTentacleCriticalMulGoal = 1.f;
		
		if (mlPermaFail_BlurId > -1) Effect_Blur_FadeOut(mlPermaFail_BlurId, 1);
		mlPermaFail_BlurId = Effect_Blur_Start(0.75, 0);
		
		mBaseObj.Timer_Add("Timer_WakeUp_Start", 1.f, "OnTimer_WakeUp_Start");
		
		/////////////////
		// 1/3 chance to add some oil to the lantern if empty
		if (mbPermaFailedOnce==false)
			mbPermaFailedOnce=true;
			
		if (mbPermaFailedOnce && cMath_RandRectl(0,2)!=0) return;
		
		if (Oil_GetCount()>0 || 
			ItemType_GetFirstInInventory("Lantern")=="" || 
			Item_GetContentLevel(ItemType_GetFirstInInventory("Lantern"))>0)
			return;
		Item_SetContent(ItemType_GetFirstInInventory("Lantern"), "Oil", 3);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_Start(uint64 alId)
	{
		mbPermaFail_Active = false;
		mbPermafail_WakeUpActive = true;
		
		Effect_Fade_In(0.01f);
		
		PlayerEmotion_PlaySound(eEmotionPlaylistType_Breathing, eEmotionSoundType_OneShotEvent, 1, "player/emotes/Tasi_Permafail_Surface", -1, 0, 0);
		Sound_PlayGui("player/UI/permafail/sequence/arm_look_stinger", 1);
		
		//Fix for wakeup dialogue?
		/*if (mbPermaFail_PlayVocals)
			Voice_PlayDelayed(GhoulProgression_GetPostPermaFailBark(), 2.f);*/
		
		Sound_FadeGlobalVolume(1.f, 0.1f, eSoundEntryType_WorldAll);
		
		cAnimationState@ pState = Map_GetEntity(PlayerBody_GetEntityName()).GetMeshEntity().GetAnimationStateFromName(msPermaFail_WakeUpAnim);
		pState.SetSpeed(1.f);
		
		FadeTentacleSizeAddTo(0.f, 0.25f);
		
		FadeLevelTo(0.f, pState.GetLength() + 0.2f, true);		
		SetForcedAddFearRate(eFearForcedRateType_PermaFail, 0.f, 0.f, false, -1.f, 2.f);
			
		mBaseObj.Timer_Add("Timer_WakeUp_ShowCrossHair", pState.GetLength(), "OnTimer_WakeUp_ShowCrossHair");	
		Effect_FOV_Shake_Start(0.06, 0, 0, 5);
	
		mBaseObj.Timer_Add("OnTimer_WakeUp_SlowAnim", 6.5f, "OnTimer_WakeUp_SlowAnim"); // Temp
		mBaseObj.Timer_Add("OnTimer_WakeUp_ResetAnim", 12.1f, "OnTimer_WakeUp_ResetAnim"); // Temp
		
		mBaseObj.Timer_Add("Timer_WakeUp_End", pState.GetLength() + 0.2f, "OnTimer_WakeUp_End");
	}
	
	//------------------------------------------------------------
	
	void OnRecieveMessage(int alMessageId, cLuxEntityMessageData @apData)
	{
		cLux_AddDebugMessage("Test");
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_ShowCrossHair(uint64 alId)
	{
		Player_ShowCrossHairIcons(true, true);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_Unblur(uint64 alId)
	{
		Effect_Blur_FadeOut(mlPermaFail_BlurId, 1.f);
		mlPermaFail_BlurId = -1;
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_SlowAnim(uint64 alId)
	{
		cAnimationState@ pState = PlayerBody_GetAnimationState(msPermaFail_WakeUpAnim);
		if (pState is null)
			return;
			
		pState.SetSpeed(0.4f);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_ResetAnim(uint64 alId)
	{
		cAnimationState@ pState = PlayerBody_GetAnimationState(msPermaFail_WakeUpAnim);
		if (pState is null)
			return;
			
		pState.SetSpeed(1.0f);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_PlayStinger(uint64 alId)
	{
		//Sound_PlayGui("player/UI/permafail/sequence/arm_look_stinger", 1);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_Shake(uint64 alId)
	{
		Effect_FOV_Shake_Start(0.015, 4.0f, 0, 1.0f);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_DoProgressionEffects(uint64 alId)
	{
		//GhoulProgression_FadeCustomArmMaterial(GhoulProgression_GetProgression()+5, 2.0f);
		cLux_AddDebugMessage("OnTimer_WakeUp_DoProgressionEffects");
		if (mbPermaFail_PlayVocals)	OnTimer_WakeUp_Breathing(0);
			
		mBaseObj.Timer_Add("OnTimer_WakeUp_EndProgressionEffects", 2.05f, "OnTimer_WakeUp_EndProgressionEffects");
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_Breathing(uint64 alId)
	{
		if (Voice_CharacterIsSpeaking("Player")==false)
			PlayerEmotion_PlaySound(eEmotionPlaylistType_Breathing, eEmotionSoundType_OneShotEvent, 1, "player/emotes/Tasi_Tentacles_Med", 5, 0, 2);
		else
			mBaseObj.Timer_Add("OnTimer_WakeUp_Breathing", 0.1f, "OnTimer_WakeUp_Breathing");
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_EndProgressionEffects(uint64 alId)
	{
		GhoulProgression_DoEffects(4.0f);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_WakeUp_End(uint64 alId)
	{
		mbPaused = false;
		mbPermafail_WakeUpActive = false;
		
		cLux_GetPlayer().ChangeState(ePlayerState_Normal);
		
		cLux_SetLookAtCallbacksActive(true);
		cLux_GetPlayer().SetCollideCallbacksActive(true);
		Hint_SetCanShowHints(true);
			
		Player_SetMoveSpeedMul(1.f, ePlayerMoveSpeedMulType_Fear);
		Player_SetLookSpeedMul(1.f);
		
		PlayerBody_ResetCutscenePitchYawLimits();
		
		// Stop music on layers above the ones that should be retained on wakeup
		for (int i = mPermafail_WakeUpMusicPrio+1; i <= eMusicPrio_OverrideAll; i++)
			Music_Stop(0, eMusicPrio(i));
		mPermafail_WakeUpMusicPrio = eMusicPrio_SceneAmb;
		
		Music_FadeVolumeMul(1.0f, 5.0f);
		
		msPermaFail_WakeUpAnim = "";
		
		if (mlPermaFail_BlurId != -1)
		{
			Effect_Blur_FadeOut(mlPermaFail_BlurId, 1.f);
			mlPermaFail_BlurId = -1;
		}
		
		if (mBaseObj.Timer_Exists("OnTimer_WakeUp_DoVeins"))
			mBaseObj.Timer_Remove("OnTimer_WakeUp_DoVeins");
		
		////////////////////
		// Show hint if player permafailed a lot
		int lGhoulProgression = GhoulProgression_GetProgression();
		int lGhoulProgressionLimit = GhoulProgression_GetLimit();
		
		// DISABLED REMINDER HINT
/*		if (lGhoulProgression == lGhoulProgressionLimit || lGhoulProgression >= lGhoulProgressionLimit / 2 + 2)
			Hint_ShowHint("Hints", "HintPermafail", false);*/
	}
	
	//------------------------------------------------------------
	
	//} END OF PERMAFAIL
	
	/////////////////////////////////////////
	// HELPERS
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	int GetClosestRegenStep(float afLevel)
	{
		for (int i = mvLevelRegenThresholds.size() - 1; i >= 0; --i)
		{
			float fThreshold = mvLevelRegenThresholds[i];
			if (afLevel >= fThreshold)
			{
				return i + 1;
			}
		}
		return 0;
	}
	
	//------------------------------------------------------------
	
	float GetFactors(bool abDarkness = false, bool abScaryObject = false, bool abThreat = false, bool abFearRateArea = false,
						bool abForced = false, bool abAgent = false, bool abPeace = false)
	{
		float fFactors = 0.0f;
		if (abDarkness) fFactors += mfDarknessFactor;
		if (abScaryObject) fFactors += mfScaryObjectFactor;
		if (abThreat) fFactors += mfThreatFactor;
		if (abFearRateArea) fFactors += mfFearRateAreaFactor;
		if (abForced) fFactors += mfForcedFactor;
		if (abAgent) fFactors += mfThreatAgentFactor;
		if (abPeace) fFactors += mfPeaceFactor;
		return fFactors;
	}

	//------------------------------------------------------------
	
	[volatile] array<cFearObject@> mvFearObjectRefs;
	bool mbRebuildFearObjectRefs = false;
	
	bool FearObjectRefsEmpty()
	{
		return mvFearObjectRefs.size() == 0 && (mvScaryObjects.size() != 0 || mvThreats.size() != 0 || mvThreatAgents.size() != 0);
	}
	
	void BuildFearObjectRefs()
	{
		mbRebuildFearObjectRefs = false;
		mvFearObjectRefs.resize(0);
		for (uint i = 0; i < mvScaryObjects.size(); ++i) mvFearObjectRefs.push_back(mvScaryObjects[i]);
		for (uint i = 0; i < mvThreats.size(); ++i) mvFearObjectRefs.push_back(mvThreats[i]);
		for (uint i = 0; i < mvThreatAgents.size(); ++i) mvFearObjectRefs.push_back(mvThreatAgents[i]);
	}
	
	array<cFearObject@>@ GetFearObjects()
	{
		if (mbRebuildFearObjectRefs || FearObjectRefsEmpty()) BuildFearObjectRefs();
		return mvFearObjectRefs;
	}
	
	int GetFearObjectCount()
	{
		if (mbRebuildFearObjectRefs || FearObjectRefsEmpty()) BuildFearObjectRefs();
		return mvFearObjectRefs.size();
	}
	
	//------------------------------------------------------------
	
	float GetFearRateTarget()
	{
		float fTargetAccum = mfDebugDarknessFactorTarget;
		for(uint i = 0; i < mvActiveFearObjects.size(); ++i)
		{
			fTargetAccum += mvActiveFearObjects[i].mfFearRateTarget;
		}
		
		for(uint i = 0; i < mvForcedFactors.size(); ++i)
		{
			fTargetAccum += mvForcedFactors[i].mfForcedFactorTarget;
		}
		
		return cMath_Min(fTargetAccum, 1.f);
	}
	
	//------------------------------------------------------------
	
	void UpdateFearAreaState()
	{
		eFearAreaState newState = mFearAreaState;

		if (mActiveFearArea.m_idArea == tID_Invalid) newState = mDefaultState;
		else if (mActiveFearArea.mbNoFear) newState = eFearAreaState_None;
		else if (mActiveFearArea.mbSafe) newState = eFearAreaState_Safe;
		else if (mActiveFearArea.mbSafe == false) newState = eFearAreaState_Unsafe;
		
		if (newState != mFearAreaState)
		{
			mlFearAreaMusicState = -1;
		}
		
		mFearAreaState = newState;
	}
	
	bool IsSituationSafe()
	{
		if (mfRate > 0.0f) return false;
		if (mFearAreaState != eFearAreaState_Safe) return false;
		return true;
	}
	
	tString FearAreaStateToString(eFearAreaState aState)
	{
		switch (aState)
		{
			case eFearAreaState_None: return "None";
			case eFearAreaState_Safe: return "Safe";
			case eFearAreaState_Unsafe: return "Unsafe";
		}
		return "";
	}
	
	//------------------------------------------------------------
	
	bool IsLookingAtScaryEntity()
	{
		return mbIsLookingAtScaryEntity;
	}
	
	//------------------------------------------------------------
	
	bool HasPermaFailScenesAdded()
	{
		return mvPermaFail_Scenes.size()>0;
	}
	
	//------------------------------------------------------------
	
	//} END OF HELPERS
	
	/////////////////////////////////////////
	// ACTIONS
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnAction(int alAction, bool abPressed)
	{
	}
	
	//------------------------------------------------------------

	void OnAnalogInput(int alAnalogId, const cVector3f &in avAmount)
	{
	
	}
	
	//------------------------------------------------------------
	
	void OnExitPressed()
	{
	
	}
	
	//------------------------------------------------------------
	
	void AppGotInputFocus()
	{
	
	}
	void AppLostInputFocus()
	{
	
	}
	
	//------------------------------------------------------------
	
	//} END OF ACTIONS
	
	/////////////////////////////////////////
	// GUI
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnGui(float afTimeStep)
	{
		if (cLux_ScriptDebugOn() == false) return;
		if (cLux_HideDebugOutputOn()) return;
		if (mbActive == false) return;
		
		float fY = 0.50f;
		
		float fPadLeft = 0.006f;
		
		/////////////////////////////
		// Meter settings
		float fMeterLength = 0.15f;
		float fMeterLineSize = 0.0015f;
		float fMeterHeight = 0.025f;
		float fMeterTextPad = 0.003f;
		float fMeterFontSize = 0.02f;
		
		cImGuiFont meterFont;
		meterFont.mvSize = ImGui_NrmSizeKeepRatio(fMeterFontSize);
		meterFont.mColor = cColor(1.0f, 1.0f, 1.0f, 1.0f);
		
		/////////////////////////////
		// Text line settings
		cImGuiFont textLineFont;
		textLineFont.mvSize = ImGui_NrmSizeKeepRatio(0.02f);
		textLineFont.mColor = cColor(1.0f, 1.0f, 1.0f, 1.0f);
		
		/////////////////////////////
		// Fear area state
		tString sActiveFearArea = "None";
		if (mActiveFearArea.m_idArea != tID_Invalid && (cLux_ID_Area(mActiveFearArea.m_idArea) !is null))
		{
			sActiveFearArea = cLux_ID_Area(mActiveFearArea.m_idArea).GetName();
		}
		bool bDarkness = true;
		if (mFearAreaState != eFearAreaState_Unsafe || (mActiveFearArea.m_idArea != tID_Invalid && mActiveFearArea.mbDarknessFear == false)) bDarkness = false;
		ImGui_DrawFontW("FearAreaState: " + FearAreaStateToString(mFearAreaState) + "    Total:  " + mvFearAreas.size() + "    Active: " + sActiveFearArea + "    Darkness: " + bDarkness + "    ProgressToken: " + mbProgressToken, textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Focus
		ImGui_DrawFontW("PermafailArea: " + msPermaFail_WakeUpArea + "    PermafailEnabled:  " + mbPermaFail_Enabled + "    PermafailActive: " + mbPermaFail_Active, textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Fear area count
		int fPerFrame = mlFearObject_GuaranteedPerFrame;
		if (mlFearObject_RemainingPerFrame > 0) ++fPerFrame;
		ImGui_DrawFontW("Paused: " + mbPaused + "    Difficulty: " + cString_ToString(mfDifficultyMul, 2) + "   FearObjects: " + GetFearObjectCount() + "    UpdatedPerFrame: " + fPerFrame, textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Focus
		ImGui_DrawFontW("Focus: " + cString_ToString(mfFocus, 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
				
		/////////////////////////////
		// Focus
//		ImGui_DrawFontW("RegenCap: " + cString_ToString(GetCurrentLevelRegenCap(), 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
//		fY += 0.02f;

		fY += 0.02f;
		
		/////////////////////////////
		// Fear level meter
		
		cColor mBarColor = cColor(1.0f, 0.0f, 1.0f, 1.0f);
		if (GetPaused()) mBarColor = cColor(1.0f, 0.5f, 0.0f, 1.0f);
		
		float fLevelMeter = mfLevel * fMeterLength;
		ImGui_DrawLine(ImGui_NrmPos2(fPadLeft, fY), ImGui_NrmPos2(fPadLeft + fMeterLength, fY), 0.1f, ImGui_NrmSize(0.0f, fMeterHeight).y, cColor(1.0f, 0.0f, 1.0f, 0.5f));
		ImGui_DrawLine(ImGui_NrmPos2(fPadLeft, fY), ImGui_NrmPos2(fPadLeft + fLevelMeter, fY), 0.2f, ImGui_NrmSize(0.0f, fMeterHeight).y, mBarColor);
		if (mbLevelRegenCapActive)
		{
			ImGui_DrawLine(ImGui_NrmPos2(fPadLeft, fY), ImGui_NrmPos2(fPadLeft + fMeterLength * GetCurrentLevelRegenCap(), fY), 0.3f, ImGui_NrmSize(0.0f, fMeterHeight).y, cColor(0.5f, 0.5f, 0.5f, 1.0f));
		}
		for (uint i = 0; i < mvLevelRegenSteps.size(); ++i)
		{
			float fStep = mvLevelRegenSteps[i];
			if (fStep <= 0.0f) continue;
			ImGui_DrawLine(ImGui_NrmPos2(fPadLeft + fMeterLength * fStep - fMeterLineSize / 2.0f, fY), ImGui_NrmPos2(fPadLeft + fMeterLength * fStep + fMeterLineSize / 2.0f, fY), 0.4f, 18.0f, cColor(1.0f, 1.0f, 1.0f, 1.0f));
		}
		ImGui_DrawFontW("Fear Level", meterFont, ImGui_NrmPos(fPadLeft + fMeterTextPad, fY - fMeterHeight / 2.5f, 0.3f), eFontAlign_Left);
		ImGui_DrawFontW(cString_ToString(mfLevel, 2), meterFont, ImGui_NrmPos(fPadLeft + fMeterLength - fMeterTextPad, fY - fMeterHeight / 2.5f, 0.3f), eFontAlign_Right);
		fY += 0.035f;
		
		/////////////////////////////
		// Fear rate meter
		float fRateMeterStart = fPadLeft + fMeterLength / 2.0f;
		float fRateMeter = mfRate * fMeterLength / 2.0f;
		ImGui_DrawLine(ImGui_NrmPos2(fPadLeft, fY), ImGui_NrmPos2(fPadLeft + fMeterLength, fY), 0.1f, ImGui_NrmSize(0.0f, fMeterHeight).y, cColor(1.0f, 0.0f, 1.0f, 0.5f));
		ImGui_DrawLine(ImGui_NrmPos2(fRateMeterStart, fY), ImGui_NrmPos2(fRateMeterStart + fRateMeter, fY), 0.2f, ImGui_NrmSize(0.0f, fMeterHeight).y, cColor(1.0f, 0.0f, 1.0f, 1.0f));
		ImGui_DrawLine(ImGui_NrmPos2(fRateMeterStart - fMeterLineSize / 2.0f, fY), ImGui_NrmPos2(fRateMeterStart + fMeterLineSize / 2.0f, fY), 0.3f, ImGui_NrmSize(0.0f, fMeterHeight).y, cColor(1.0f, 1.0f, 1.0f, 1.0f));
		ImGui_DrawFontW("Fear Rate", meterFont, ImGui_NrmPos(fPadLeft + fMeterTextPad, fY - fMeterHeight / 2.5f, 0.3f), eFontAlign_Left);
		ImGui_DrawFontW(cString_ToString(mfRate, 2), meterFont, ImGui_NrmPos(fPadLeft + fMeterLength - fMeterTextPad, fY - fMeterHeight / 2.5f, 0.3f), eFontAlign_Right);
		fY += 0.02f;
		
		/////////////////////////////
		// Darkness factor
		ImGui_DrawFontW("Darkness: " + cString_ToString(mfDarknessFactor, 2) + "    Target: " + cString_ToString(mfDebugDarknessFactorTarget, 2) + "    Brightness: " + cString_ToString(cLux_GetLogAverageBrightness() * 100, 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Scary object factor
		ImGui_DrawFontW("ScaryObjects: " + cString_ToString(mfScaryObjectFactor, 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Threat factor
		ImGui_DrawFontW("Threats: " + cString_ToString(mfThreatFactor, 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Threat agent factor
		ImGui_DrawFontW("ThreatAgents: " + cString_ToString(mfThreatAgentFactor, 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Fear rate area factor
		tString sFearRateAreaDebug = "FearRateArea: " + cString_ToString(mfFearRateAreaFactor, 2);
		if (mActiveFearRateArea !is null && mActiveFearRateArea.m_idArea != tID_Invalid)
		{
			sFearRateAreaDebug += " (" + cLux_ID_Area(mActiveFearRateArea.m_idArea).GetName() + ")";
		}
		ImGui_DrawFontW(sFearRateAreaDebug, textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Forced factor
		ImGui_DrawFontW("Forced: " + cString_ToString(mfForcedFactor, 2), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		fY += 0.02f;

		for (uint i = 0; i < mvActiveFearObjects.size(); ++i)
		{
			tString sDebugLine = "";
			cFearObject@ pFearObject = mvActiveFearObjects[i];
			if (cLux_ID_Entity(pFearObject.m_idEntity) !is null) continue;
			switch(pFearObject.mType)
			{
				case eFearObject_ScaryObject:
					sDebugLine += "ScaryObj: " + cLux_ID_Entity(pFearObject.m_idEntity).GetName() + " (" + cString_ToString(pFearObject.mfFearRate / mvFearObjectFalloff[i], 2) + " x " + cString_ToString(mvFearObjectFalloff[i], 2) + " = " + cString_ToString(pFearObject.mfFearRate, 2) + ")";
					break;
					
				case eFearObject_Threat:
					sDebugLine += "Threat: " + cLux_ID_Entity(pFearObject.m_idEntity).GetName() + " (" + cString_ToString(pFearObject.mfFearRate, 2) + ")";
					break;
					
				case eFearObject_ThreatAgent:
					sDebugLine += "ThreatAgent: " + cLux_ID_Entity(pFearObject.m_idEntity).GetName() + " (" + cString_ToString(pFearObject.mfFearRate, 2) + ")";
					for (uint j = 0; j < mvThreatAgents.size(); ++j)
					{
						cFearThreatAgent@ pAgent = mvThreatAgents[j];
						iLuxEntity@ pEnt = pAgent.GetEntity();
						if (pEnt is null) continue;
						if (pEnt.GetID() == pFearObject.GetEntity().GetID())
						{
							sDebugLine += " (Target: " + cString_ToString(pAgent.mfFearRateTarget, 2) + " Active: " + cString_ToString(pAgent.mfActiveFactorValue, 2) + " RateBoost: " + cString_ToString(pAgent.mfFearRateBoostFactorValue, 2) + " Hear: " + cString_ToString(pAgent.mfHearFactorValue, 2) + " LookAt: " + cString_ToString(pAgent.mfLookAtFactorValue, 2) + " Surprise: " + cString_ToString(pAgent.mfSurpriseFactorValue, 2) + ")";
 						}
					}
					break;
			}
			
			ImGui_DrawFontW(sDebugLine, textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
			fY += 0.02f;
		}
		
		
		/////////////////////////////
		// Fear rate target
		ImGui_DrawFontW("Total FearRate target: " + GetFearRateTarget(), textLineFont, ImGui_NrmPos(fPadLeft, fY, 0.1f), eFontAlign_Left);
		fY += 0.02f;
		
		/////////////////////////////
		// Level cap increased
		if (mbLevelCapIncreasedGui)
		{
			cImGuiFont permaFailFont;
			permaFailFont.mvSize = ImGui_NrmSizeKeepRatio(0.1f);
			permaFailFont.mColor = cColor(1.0f, 0.0f, 0.0f, 1.0f);
			ImGui_DrawFontW("FEAR LEVEL CAP INCREASED!", permaFailFont, ImGui_NrmPos(0.5f, 0.5f, 10.0f), eFontAlign_Center);
		}
		
	}
	
	//-------------------------------------------------------
	
	void OnDraw(float afFrameTime)
	{
		
	}
	
	//------------------------------------------------------------
	
	void OnPostRender(float afFrameTime)
	{
	}
	
	cVector3f vTestPos;
	cVector3f vTestPos2;
	void OnRenderSolid(cRendererCallbackFunctions@ apFunctions)
	{
//		apFunctions.GetLowLevelGfx().DrawSphere(vTestPos, 0.5f, cColor(1,1,0,1));
//		apFunctions.GetLowLevelGfx().DrawSphere(vTestPos2, 0.5f, cColor(1,0,0,1));
//		apFunctions.GetLowLevelGfx().DrawSphere(gvTestPos, 0.5f, cColor(1,0,0,1));
	}
	
	
	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afStartY)
	{
		afStartY = cLux_DrawDebugText("------------FEAR-----------", afStartY);
		afStartY = cLux_DrawDebugText("Current level: " + mfLevel, afStartY);
		return afStartY;
	}
	
	//------------------------------------------------------------
	
	//} END OF GUI
	
	/////////////////////////////////////////
	// PROPERTIES
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfRateMin = 0.15f;
	
	eFearAreaState mFearAreaState = eFearAreaState_None;
	array<cFearAreaInfo> mvInsideFearAreas;
	cFearAreaInfo mActiveFearArea;
	
	array<cFearScaryObject> mvScaryObjects;
	array<cFearThreat> mvThreats;
	array<cFearThreatAgent> mvThreatAgents;
	[volatile] array<cFearObject@> mvActiveFearObjects;

	bool mbActive = false;
	bool mbPaused = false;
	bool mbInitialized = false;
	bool mbDarknessActive = true;
	eFearAreaState mDefaultState = eFearAreaState_None;
	float mfLevel = 0.0f;
	float mfMaxLevel = 1.0f;
	float mfRate = 0.0f;
	float mfDifficultyMul = 1.0f;
	array<cFearRateMul> mvRateMuls;
	float mfFocus = 0.0f;
	float mfHealthShield = 0.0f;
	bool mbForceSafeSituation = false;
	
	bool mbDarknessAverageActive = false;
	float mfFearRateAreaRate = 0.0f;
	float mfFearLevelRateMul = 1.0f;
	tString msFearAreaMusic = "";
	bool mbProgressToken = false;
	int mlFearAreaAddedCount = 0;
	float mfCracklingLevel = 0;
	float mfFearTentaclesMul = 0.f;
    
    bool mbSafeRoomBabyKickDone = false;
    float mfTimeSinceSafeRoomEnter = 0.f;
    float mfTimeSincePostKickSafeRoomExit = 9999999.f;
	
	//------------------------------------------------------------
	
	//} END OF PROPERTIES

}

//----------------------------------------------------------------------------------------

class cFearAreaInfo
{
	tID m_idArea = tID_Invalid;
	tString msMap = "";
	bool mbCollidesWithPlayer = false;
	int mlPriority = 0;
	int mlAddedId = 0;
	bool mbSafe = false;
	bool mbNoFear = false;
	bool mbDarknessFear = true;
	float mfBabyKickRateMultiplier = 1.f;
	bool mbLocked = false;
	tString msUnsafeMusic = "";
	tString msSafeMusic = "";
	float mfNonAgentRateCap = 0.8f;
	bool mbProgressInside = false;
	bool mbAllowProgressWithToken = true;
	bool mbAllowProgressWithoutToken = false;
	int mlProgressCounter = 0;
	int mlMaxProgressCount = 1;
	int mlProgressAmount = 1;
	
	int opCmp(const cFearAreaInfo &in other)
	{
		if (mlPriority < other.mlPriority) return -1;
		if (mlPriority > other.mlPriority) return 1;
		if (mbSafe && other.mbSafe == false) return -1;
		if (mbSafe == false && other.mbSafe) return 1;
		if (mlAddedId < other.mlAddedId) return -1;
		if (mlAddedId > other.mlAddedId) return 1;
		return 0;
	}
}


//----------------------------------------------------------------------------------------

class cFearRateAreaInfo
{
	tID m_idArea = tID_Invalid;
	tString msMap = "";
	float mfFearRate = 0.0f;
	int mlPriority = 0;
	float mfIncreaseSpeed = -1.0f;
	float mfDecreaseSpeed = -1.0f;
	bool mbCollidesWithPlayer = false;
	
	int opCmp(const cFearRateAreaInfo &in other)
	{
		if (mlPriority < other.mlPriority) return -1;
		if (mlPriority > other.mlPriority) return 1;
		if (mfFearRate > other.mfFearRate) return 1;
		if (mfFearRate < other.mfFearRate) return -1;
		return 0;
	}
}

//----------------------------------------------------------------------------------------

/////////////////////////////////////////
// FEAR OBJECT BASE
/////////////////////////////////////////

//----------------------------------------------------------------------------------------

class cFearObject
{
	//------------------------------------------------------------
	
	cFearObject() {}
	
	cFearObject(cFearObjectParams@ apParams)
	{
		m_idEntity = apParams.m_idEntity;		
		mfBaseFearRate = apParams.mfBaseFearRate;
		mfSurpriseFactor = apParams.mfSurpriseFactor;
		mfLookAtFactor = apParams.mfLookAtFactor;
		mfActivationDistance = apParams.mfActivationDistance;
		mfDeactivationDistance = apParams.mfDeactivationDistance;
		mfActivationDelay = apParams.mfActivationDelay;
		mfActivationLightLevel = apParams.mfActivationLightLevel;
		msActivationCallback = apParams.msActivationCallback;
		msDeactivationCallback = apParams.msDeactivationCallback;
		msActivationTriggers = apParams.msActivationTriggers;
		mbLookAtDetectWholeArea = apParams.mbLookAtDetectWholeArea;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Editor settings
	bool mbFearActive = false;
	float mfBaseFearRate = 0.1;
	float mfSurpriseFactor = -1.0f;
	float mfLookAtFactor = -1.0f;
	float mfActivationDistance = 15.0f;
	float mfDeactivationDistance = 8.0f;
	float mfActivationDelay = 0.0f;
	float mfActivationEffectDelay = 0.0f; // TODO: add to editor
	float mfActivationLightLevel = -1.0f;
	tString msActivationCallback = "";
	tString msDeactivationCallback = "";
	tString msActivationTriggers = "";
	
	float mfBaseFearRateMul = 1.0f;
	
	float  mfSurpriseFactorValue = 0.0f;
	float  mfActiveFactorValue = 0.0f;
	float  mfFearRateBoostFactorValue = 0.0f;
	float  mfLookAtFactorValue = 0.0f;
	
	/////////////////////////////
	// Helper settings
	bool mbManualActivation = false;
	
	/////////////////////////////
	// Area specific settings
	bool mbLookAtDetectWholeArea = false;
	
	/////////////////////////////
	// Component settings
	bool mbEnabled = true;
	float mfOverrideFactor = -1.0f;
	
	/////////////////////////////
	// Settings
	float mfMinRequiredFearRate = 0.05f;
	float mfSurpriseEffectTime = 2.5f;
	float mfIncreaseSpeed = 1.0f / 5.0f;
	float mfDecreaseSpeed = 1.0f / 8.0f;
	
	eFearObject mType;
	tID m_idEntity = tID_Invalid;
	array<tID> mvTriggerEntities;
	float mfFearRate = 0.0f;
	float mfFearRateTarget = 0.0f;
	float mfFalloffMul = 1.0f;
	int mlIndex;
	bool mbPeriodicUpdateActive = false;
	
	float mfFearRateBoostFactor = 0.0f;
	float mfBoostIncreaseSpeed = -1.0f;
	float mfBoostDecreaseSpeed = -1.0f;
	bool mbBoostDoGasp = false;
	
	// TODO: refactor this
	bool mbCheckOnScreenOutOfRange = true;
	
	bool mbOnScreen = false;
	bool mbLos = false;
	bool mbLit = false;
	float mfPlayerDistSqr = 0.0f;
	
	bool mbSurpriseEffectOver = false;
	bool mbCanGasp = true;
	bool mbGasped = false;
	
	[volatile] cScrFearHandler@ mpFearHandler;
	tID m_idActivationEntity = tID_Invalid; // TODO: find a more elegant solution
	
	//------------------------------------------------------------
	
	void Init()
	{
	}
	
	void SetEnabled(bool abEnabled)
	{
		if (mbEnabled == abEnabled) return;
		mbEnabled = abEnabled;
	}
	
	bool GetEnabled()
	{
		return mbEnabled && mfFearRate == 0.0f;
	}
	
	bool IsSeen()
	{
		return mbOnScreen && mbLos && mbLit;
	}
	
	iLuxEntity@ GetEntity()
	{
		return cLux_ID_Entity(m_idEntity);
	}
	
	tString GetEntityName()
	{
		iLuxEntity@ pEnt = cLux_ID_Entity(m_idEntity);
		if (pEnt is null) return "";
		return pEnt.GetName();
	}
	
	int opCmp(const cFearObject &in other)
	{
		if (mfFearRate < other.mfFearRate) return -1;
		if (mfFearRate > other.mfFearRate) return 1;
		return 0;
	}
	
	void Update(float afTimeStep)
	{
		iLuxEntity@ pEnt = GetEntity();
		if (pEnt is null) return;
		if ((pEnt.IsActive() == false || mbEnabled == false) && mfFearRate <= 0.0f) return;
		
		UpdateTimers(afTimeStep);

		float fIncreaseSpeed = mfIncreaseSpeed;
		float fDecreaseSpeed = mfDecreaseSpeed;
		
		bool bFearBoostActive = mfFearBoostTimer > 0.0f && mfFearBoostTimer <= mfFearBoostDuration;
		if (bFearBoostActive && mfBoostIncreaseSpeed >= 0.0f) fIncreaseSpeed = mfBoostIncreaseSpeed;
		if (mfFearBoostDecreaseTimer > 0.0f && mfBoostDecreaseSpeed >= 0.0f) fDecreaseSpeed = mfBoostDecreaseSpeed;
		bool bDefaultBoost = bFearBoostActive && mfBoostIncreaseSpeed < 0.0f;
		
		float fSpeed = mfFearRateTarget >= mfFearRate ? fIncreaseSpeed : fDecreaseSpeed;
		if (mfSurpriseTimer > 0.0f || bDefaultBoost) fSpeed *= 2.5f;
		
		float fRateDiff = cMath_Max(0.0f, mfFearRateTarget - mfFearRate);
		fSpeed *= (1.0f + fRateDiff) * 3.0f;
		
		mfFearRate = cMath_IncreaseTo(mfFearRate, fSpeed * afTimeStep, mfFearRateTarget);
	}
	
	//------------------------------------------------------------
	
	float mfSurpriseTimer = -1.0f;
	float mfFearBoostTimer = -1.0f;
	float mfFearBoostDecreaseTimer = -1.0f;
	float mfActivationDelayTimer = -1.0f;
	float mfActivationEffectDelayTimer = -1.0f;
	float mfLookAtAreaLosTimer = -1.0f;
	float mfLookAtAreaLitTimer = -1.0f;
	
	void UpdateTimers(float afTimeStep)
	{
		/////////////////////////////
		// Surprise timer
		if (mfSurpriseTimer >= 0.0f)
		{
			mfSurpriseTimer -= afTimeStep;
		}
		
		/////////////////////////////
		// Fear boost timer
		if (mfFearBoostTimer >= 0.0f)
		{
			if (gbCanGasp && mbBoostDoGasp && mfFearBoostTimer <= mfFearBoostDuration) FearHandler_PlayGasp(0.0f, mfFearRateBoostFactor);
			mfFearBoostTimer -= afTimeStep;
		}
		
		if (mfFearBoostDecreaseTimer >= 0.0f)
		{
			mfFearBoostDecreaseTimer -= afTimeStep;
		}
		
		/////////////////////////////
		// Activation delay timer
		if (mfActivationDelayTimer >= 0.0f)
		{
			mfActivationDelayTimer -= afTimeStep;
			if (mfActivationDelayTimer < 0.0f)
			{
				mfActivationDelayTimer = -1.0f;
				Activate();
			}
		}
		
		/////////////////////////////
		// Activation effect delay timer
		if (mfActivationEffectDelayTimer >= 0.0f)
		{
			mfActivationEffectDelayTimer -= afTimeStep;
			if (mfActivationEffectDelayTimer < 0.0f)
			{
				mfActivationEffectDelayTimer = -1.0f;
				ActivateEffects();
			}
		}
		
		if (mfLookAtAreaLosTimer >= 0.0f)
		{
			mfLookAtAreaLosTimer -= afTimeStep;
		}
		
		if (mfLookAtAreaLitTimer >= 0.0f)
		{
			mfLookAtAreaLitTimer -= afTimeStep;
		}
	}
	
	//------------------------------------------------------------
	
	void PeriodicUpdate(cScrFearHandler@ pFearHandler)
	{
		iLuxEntity@ pEnt = GetEntity();
		if (pEnt is null ||
			pEnt.IsActive() == false || 
			mbEnabled == false || 
			mbPeriodicUpdateActive ||
			cLux_GetPlayer().GetCurrentStateId() == ePlayerState_Dead)
		{
			mfFearRateTarget = 0.0f;
			return;
		}
		
		@mpFearHandler = pFearHandler;
			
		mbPeriodicUpdateActive = true;
		DoLookAtRaycasts(pFearHandler);
	}
	
	void PostLookAtUpdate(bool abRaycastDone = true)
	{	
		if (abRaycastDone)
		{
			if (mbLookAtDetectWholeArea) UpdateLookAtWholeArea();
			else UpdateLookAtCenter();
		}
		
		UpdateActivation();
		UpdateFearRateTarget();
		PostFearRateTargetUpdate();
		mbPeriodicUpdateActive = false;
	}
	
	void DoLookAtRaycasts(cScrFearHandler@ pFearHandler)
	{
		iLuxEntity@ pEnt = GetEntity();
		mfPlayerDistSqr = cMath_Vector3DistSqr(cLux_GetPlayer().GetCharacterBody().GetPosition(), pEnt.GetPosition());
		
		if (mbCheckOnScreenOutOfRange)
		{
			cVector3f vToPlayer = cLux_GetPlayer().GetCharacterBody().GetPosition() - pEnt.GetPosition();
			if (vToPlayer.SqrLength() > mfActivationDistance * mfActivationDistance)
			{
				mbOnScreen = mbLos = mbLit = false;
				mbPeriodicUpdateActive = false;
				PostLookAtUpdate(false);
				return;
			}
		}
		
		mlRaycastIndex = 0;
		if (mbLookAtDetectWholeArea)
		{
			mvLookAtWholeArea_Points.resize(0);
			mvLookAtWholeArea_PointLos.resize(0);
			
			cLuxArea@ pArea = cLux_ToArea(pEnt);
			cVector3f vMax = pArea.GetSize() / 2.0f;
			cVector3f vMin = pArea.GetSize() / -2.0f;
			
			for (int i = 0; i < mlLookAtWholeArea_RaycastCount; ++i)
			{
				/////////////////////////////
				// Pick random point in area
				cVector3f vRandomPoint = cMath_RandRectVector3f(vMin, vMax);
				vRandomPoint = cMath_MatrixMul(pArea.GetMatrix().GetRotation(), vRandomPoint);
				vRandomPoint += pArea.GetPosition();
				mvLookAtWholeArea_Points.push_back(vRandomPoint);
				mvLookAtWholeArea_PointLos.push_back(false);
				
				mpFearHandler.mBaseObj.CheckLineOfSight("OnLineOfSight_FearObject", Player_GetCameraPosition(), vRandomPoint, true, false, mlIndex, pEnt);
			}
		}
		else
		{
			mbLookAtCenter_Los1 = mbLookAtCenter_Los2 = false;
			
			mpFearHandler.mBaseObj.CheckLineOfSight("OnLineOfSight_FearObject", Player_GetCameraPosition(), pEnt.GetPosition(), true, false, mlIndex, pEnt);
			if (pEnt.GetBodyNum() > 0)
			{
				float fHeight = pEnt.GetMainBody().GetBoundingVolume().GetSize().y;
				cVector3f vLos2Pos = pEnt.GetPosition();
				vLos2Pos.y += fHeight / 2.0f;
				mpFearHandler.mBaseObj.CheckLineOfSight("OnLineOfSight_FearObject", Player_GetCameraPosition(), vLos2Pos, true, false, mlIndex, pEnt);
			}
		}
	}
	
	int mlRaycastIndex = 0;
	void OnLineOfSight_Update(bool abSuccessful)
	{
		iLuxEntity@ pEnt = GetEntity();
		if (mbLookAtDetectWholeArea)
		{
			mvLookAtWholeArea_PointLos[mlRaycastIndex] = abSuccessful;
			if (mlRaycastIndex == 2) PostLookAtUpdate();
		}
		else
		{
			if (mlRaycastIndex == 0) mbLookAtCenter_Los1 = abSuccessful;
			else if (mlRaycastIndex == 1) mbLookAtCenter_Los2 = abSuccessful;
			
			if ((mlRaycastIndex == 0 && pEnt.GetBodyNum() <= 0) || mlRaycastIndex == 1) PostLookAtUpdate();
		}
		++mlRaycastIndex;
	}
	
	
	int mlLookAtWholeArea_RaycastCount = 3;
	float mfLookAtWholeArea_DeactivationTime = 0.5f;
	array<cVector3f> mvLookAtWholeArea_Points;
	array<bool> mvLookAtWholeArea_PointLos;
	
	void UpdateLookAtWholeArea()
	{
		iLuxEntity@ pEnt = GetEntity();
		
		/////////////////////////////
		// Check on screen
		mbOnScreen = pEnt.CheckIsOnScreen(false);
		
		/////////////////////////////
		// Cast rays to random points and check points for LOS and lit
		cLuxArea@ pArea = cLux_ToArea(pEnt);
		cVector3f vMax = pArea.GetSize() / 2.0f;
		cVector3f vMin = pArea.GetSize() / -2.0f;
		bool bPointLos = false;
		bool bPointLit = false;
		for (int i = 0; i < mlLookAtWholeArea_RaycastCount; ++i)
		{
			/////////////////////////////
			// Check point LOS
			bool bLos = mvLookAtWholeArea_PointLos[i];
			if (bLos) bPointLos = true;
			
			/////////////////////////////
			// Check point lit
			if (mfActivationLightLevel >= 0.0f)
			{
				float fLightLevel = cLux_GetLightLevelAtPos(mvLookAtWholeArea_Points[i], null, 0.5f);
				fLightLevel += GetNightVisionLightLevel(mvLookAtWholeArea_Points[i]);
				if (fLightLevel >= mfActivationLightLevel) bPointLit = true;
			}
			else
			{
				bPointLit = true;
			}
			
			if (bPointLos && bPointLit) break;
		}
		
		/////////////////////////////
		// LOS counter
		if (bPointLos)
		{
			mfLookAtAreaLosTimer = mfLookAtWholeArea_DeactivationTime;
		}
		mbLos = mfLookAtAreaLosTimer > 0.0f;
		
		/////////////////////////////
		// Lit counter
		if (bPointLit)
		{
			mfLookAtAreaLitTimer = mfLookAtWholeArea_DeactivationTime;
		}
		mbLit = mfLookAtAreaLitTimer > 0.0f;
	}
	
	bool mbLookAtCenter_Los1 = false;
	bool mbLookAtCenter_Los2 = false;
	void UpdateLookAtCenter()
	{
		mbOnScreen = mbLos = mbLit = false;
		
		iLuxEntity@ pEntity = GetEntity();
		if (pEntity is null || pEntity.IsActive() == false) return;
				
		/////////////////////////////
		// Check on screen
		mbOnScreen = pEntity.CheckIsOnScreen(false);

		/////////////////////////////
		// Check LOS
		mbLos = mbLookAtCenter_Los1 || mbLookAtCenter_Los2;
				
		/////////////////////////////
		// Check lit
		mbLit = true;
		if (mfActivationLightLevel >= 0.0f)
		{
			float fLightLevel = 0.0f;
			
			/////////////////////////////
			// Areas: check at center of bounding volume
			if (pEntity.GetEntityType() == eLuxEntityType_Area)
			{
				cBoundingVolume@ pBv = pEntity.GetMainBody().GetBoundingVolume();
				fLightLevel = cLux_GetLightLevelAtPos(pBv.GetWorldCenter(), null, pBv.GetRadius());
				fLightLevel += GetNightVisionLightLevel(pBv.GetWorldCenter());
			}
			
			/////////////////////////////
			// Other entities: check at radius distance away from center, to avoid mesh casting shadow on center
			else
			{
				cBoundingVolume@ pBv = pEntity.GetMeshEntity().GetBoundingVolume();
				cVector3f vToCamera = cLux_GetPlayer().GetCamera().GetPosition() - pBv.GetWorldCenter();
				float fToCameraDist = vToCamera.Length();
				vToCamera.Normalize();
				
				if (fToCameraDist <= pBv.GetRadius() && Item_IsLightSourceActive())
				{
					fLightLevel = 100.0f;
				}
				else
				{
					cVector3f vLightLevelPos = pBv.GetWorldCenter() + vToCamera * pBv.GetRadius();
					fLightLevel = cLux_GetLightLevelAtPos(vLightLevelPos, null, 0.0f);
					fLightLevel += GetNightVisionLightLevel(vLightLevelPos);
				}
			}
			
			// Check activation threshold
			if (fLightLevel < mfActivationLightLevel) mbLit = false;
		}
				
		m_idActivationEntity = pEntity.GetID();
	}
	
	float GetNightVisionLightLevel(const cVector3f&in avPos)
	{
		if (mpFearHandler.mbNightVisionActive)
		{
			float fDist = cMath_Vector3Dist(avPos, Player_GetPosition());
			float fAdd = cMath_Max(0.0f, 1.0f - (fDist / mpFearHandler.mfNightVisionRadiusMax)) * mpFearHandler.mfNightVisionBrightness;
			return fAdd;
		}
		return 0.0f;
	}
	
	void UpdateActivation()
	{	
		if (mbManualActivation) return;
		
		if (mbFearActive == false)
		{
			if (CanActivate())
			{
				if (mfActivationDelayTimer < 0.0f)
				{
					mfActivationDelayTimer = mfActivationDelay;
				}
			}
			else
			{
				mfActivationDelayTimer = -1.0f;
			}
		}
		else
		{
			if (CanDeactivate())
			{
				Deactivate();
			}
		}
	}
	
	bool CanActivate()
	{
		/////////////////////////////
		// Check distance
		cVector3f vToPlayer = cLux_GetPlayer().GetCharacterBody().GetPosition() - GetEntity().GetPosition();
		if (vToPlayer.SqrLength() > mfActivationDistance * mfActivationDistance) return false;

		/////////////////////////////
		// Check if looked at
		if (mbOnScreen == false) return false;
		if (mbLos == false) return false;
		if (mbLit == false) return false;
		
		return true;
	}
	
	bool CanDeactivate()
	{
		/////////////////////////////
		// Check distance
		cVector3f vToPlayer = cLux_GetPlayer().GetCharacterBody().GetPosition() - GetEntity().GetPosition();
		if (vToPlayer.SqrLength() > mfDeactivationDistance * mfActivationDistance) return true;
		
		/////////////////////////////
		// Check LOS
		if (mbLos == false) return true;
		
		return false;
	}
	
	void UpdateFearRateTarget()
	{
		mfFearRateTarget = 0.0f;
		
		if (mbFearActive == false) return;
		if (mfOverrideFactor > 0.0f)
		{
			mfFearRateTarget = mfOverrideFactor;
			return;
		}
		
		mfActiveFactorValue = GetActiveFactor();
		mfSurpriseFactorValue = GetSurpriseFactor();
		mfFearRateBoostFactorValue = GetFearRateBoostFactor();
		mfLookAtFactorValue = GetLookAtFactor();
		
		mfFearRateTarget += mfActiveFactorValue;
		mfFearRateTarget += mfSurpriseFactorValue;
		mfFearRateTarget += mfFearRateBoostFactorValue;
		mfFearRateTarget += mfLookAtFactorValue;
	}
	
	float mfPrevFearRateTarget = 0.0f;
	void PostFearRateTargetUpdate()
	{
		/////////////////////////////
		// Don't add tiny values
		if (mfFearRateTarget < mfMinRequiredFearRate) mfFearRateTarget = 0.0f;
		
		/////////////////////////////
		// Apply falloff
		mfFearRateTarget *= mfFalloffMul;
		
		/////////////////////////////
		// Gasp only once
		if (gbCanGasp && mbCanGasp && mbGasped == false && mfFearBoostTimer <= 0.0f)
			mbGasped = FearHandler_PlayGasp(mfPrevFearRateTarget, mfFearRateTarget, true);
		mfPrevFearRateTarget = mfFearRateTarget;
	}
	
	float GetActiveFactor()
	{
		return 0.0f;
	}
	
	float GetSurpriseFactor()
	{
		if (mfSurpriseTimer <= 0.0f) return 0.0f;
		if (mfSurpriseFactor < 0.0f) return mfBaseFearRate * mfBaseFearRateMul;
		return mfSurpriseFactor;
	}
	
	float GetFearRateBoostFactor()
	{
		if (mfFearBoostTimer <= 0.0f || mfFearBoostTimer > mfFearBoostDuration) return 0.0f;
		return mfFearRateBoostFactor;
	}
	
	float GetLookAtFactor()
	{
		if (mbOnScreen == false || mbLos == false || mbLit == false) return 0.0f;
		if (mfLookAtFactor < 0.0f) return mfBaseFearRate * mfBaseFearRateMul;
		return mfLookAtFactor;
	}
	
	void Activate(float afEffectDelay = -1.0f)
	{
		if (mbFearActive) return;
		mbFearActive = true;
		mfActivationEffectDelayTimer = afEffectDelay < 0.0f ? mfActivationEffectDelay : afEffectDelay;
		
		if (msActivationCallback != "")
		{
			iLuxEntity@ pEnt = GetEntity();
			tString sMethodName = "void " + msActivationCallback + "(const tString &in asEntity)";
			cLuxMap@ pMap = pEnt.GetMap();
			if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
			{ 
				tString sName = pEnt.GetName();
				pMap.SetArgString(0, sName);
				pMap.ScriptExecute();
			}
		}

	}
	
	void Deactivate()
	{
		if (mbFearActive == false) return;
		mbFearActive = false;
		
		if (msDeactivationCallback != "")
		{
			iLuxEntity@ pEnt = GetEntity();
			tString sMethodName = "void " + msDeactivationCallback + "(const tString &in asEntity)";
			cLuxMap@ pMap = pEnt.GetMap();
			if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
			{ 
				tString sName = pEnt.GetName();
				pMap.SetArgString(0, sName);
				pMap.ScriptExecute();
			}
		}
	}

	void ActivateEffects()
	{
		if (mbSurpriseEffectOver == false)
		{
			mbSurpriseEffectOver = true;
			mfSurpriseTimer = mfSurpriseEffectTime;
		}
	}
	
	float GetFearRate()
	{
		return mfFearRate;
	}
	
	float mfFearBoostDuration;
	void SetFearRateBoost(float afAmount, float afTime, bool abGasp = true, float afIncreaseSpeed = -1.0f, float afDecreaseSpeed = -1.0f, float afDelay = 0.0f)
	{
		if (afIncreaseSpeed == 0.0f) afIncreaseSpeed = 0.001f;
		if (afDecreaseSpeed == 0.0f) afDecreaseSpeed = 0.001f;
		
		mbBoostDoGasp = abGasp;
		mfFearRateBoostFactor = afAmount;
		mfFearBoostDuration = afTime;
		mfFearBoostTimer = afDelay + afTime;
		mfFearBoostDecreaseTimer = afDelay + afTime + (afAmount / afDecreaseSpeed);
		mfBoostIncreaseSpeed = afIncreaseSpeed;
		mfBoostDecreaseSpeed = afDecreaseSpeed;
	}
	
	//------------------------------------------------------------
}

//----------------------------------------------------------------------------------------

/////////////////////////////////////////
// FEAR SCARY OBJECT
/////////////////////////////////////////

//----------------------------------------------------------------------------------------

class cFearScaryObject : cFearObject
{
	//------------------------------------------------------------
	
	cFearScaryObject() {}
	
	cFearScaryObject(cFearScaryObjectParams@ apParams)
	{
		super(apParams);
		mType = eFearObject_ScaryObject;
		mfInteractFactor = apParams.mfInteractFactor;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Editor settings
	float mfInteractFactor = -1.0f;
	
	float mfInteractFactorValue = 0.0f;

	//------------------------------------------------------------
	
	void UpdateFearRateTarget() override
	{
		cFearObject::UpdateFearRateTarget();
		
		if (mbFearActive == false) return;
		if (mfOverrideFactor > 0.0f) return;
		
		mfInteractFactorValue = GetInteractFactor();
		mfFearRateTarget += mfInteractFactorValue;
	}
	
	float GetActiveFactor() override
	{
//		return mfBaseFearRate * mfBaseFearRateMul;
		return 0.0f;
	}
	
	float GetLookAtFactor() override
	{
		if (mbOnScreen == false || mbLos == false || mbLit == false) return 0.0f;
		if (mfLookAtFactor < 0.0f) return 2.0f * mfBaseFearRate * mfBaseFearRateMul;
		return mfLookAtFactor;
	}
	
	float GetInteractFactor()
	{
		if (GetEntity().IsInteractedWith() == false) return 0.0f;
		if (mfInteractFactor < 0.0f) return mfBaseFearRate * mfBaseFearRateMul;
		return mfInteractFactor;
	}
	
	//------------------------------------------------------------
}

//----------------------------------------------------------------------------------------

/////////////////////////////////////////
// FEAR THREAT
/////////////////////////////////////////

//----------------------------------------------------------------------------------------

class cFearThreat : cFearObject
{
	//------------------------------------------------------------
	
	cFearThreat() {}
	
	cFearThreat(cFearThreatParams@ apParams)
	{
		super(apParams);
		mType = eFearObject_Threat;
		mfMaxFearDist = apParams.mfMaxFearDist;
		mfMinFearDist = apParams.mfActivationDistance;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Editor settings
	float mfMaxFearDist = 4.0f;
	float mfMinFearDist = 10.0f;
	
	/////////////////////////////
	// Settings

	//------------------------------------------------------------
	
	float GetActiveFactor() override
	{
		/////////////////////////////
		// Distance falloff
		cVector3f vToPlayer = cLux_GetPlayer().GetCharacterBody().GetPosition() - GetEntity().GetPosition();
		float fDist = vToPlayer.Length();
		if (fDist > mfMinFearDist) return 0.0f;
		if (mfMinFearDist <= mfMaxFearDist) return 1.0f;
		float fDistFactor = 1.0f - cMath_Clamp((fDist - mfMaxFearDist) / (mfMinFearDist - mfMaxFearDist), 0.0f, 1.0f);
		return mfBaseFearRate * mfBaseFearRateMul * fDistFactor;
	}
	
	float GetLookAtFactor() override
	{
		if (mbOnScreen == false || mbLos == false || mbLit == false) return 0.0f;
		if (mfLookAtFactor < 0.0f) return 2.0f * mfBaseFearRate * mfBaseFearRateMul;
		return mfLookAtFactor;
	}
	
	//------------------------------------------------------------
}
	
//----------------------------------------------------------------------------------------

/////////////////////////////////////////
// FEAR THREAT AGENT
/////////////////////////////////////////

//----------------------------------------------------------------------------------------

class cFearThreatAgent : cFearThreat
{
	//------------------------------------------------------------
	
	cFearThreatAgent() {}
	
	cFearThreatAgent(cFearThreatParams@ apParams)
	{
		super(apParams);
		mType = eFearObject_ThreatAgent;
		mbCheckOnScreenOutOfRange = false;
		mfMinFearDist = apParams.mfMinFearDist;
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////
	// Settings
	
	float mfHearFactorValue = 0.0f;

	//------------------------------------------------------------
	
	void HeardByPlayer()
	{
		Activate(1.5f);
		mfHeardTimer = 1.0f;
		mfDeactivationTimer = 0.0f;
	}
	
	void Update(float afTimeStep) override
	{
		cFearObject::Update(afTimeStep);
	}
	
	float mfHeardTimer = -1.0f;
	float mfDeactivationTimer = 0.0f;
	void UpdateTimers(float afTimeStep) override
	{
		cFearObject::UpdateTimers(afTimeStep);
		
		if (mfHeardTimer >= 0.0f)
		{
			mfHeardTimer -= afTimeStep;
		}
		
		if (mbFearActive)
		{
			mfDeactivationTimer += afTimeStep;
			if (mfDeactivationTimer >= 15.0f)
			{
				mfDeactivationTimer = 0.0f;
				Deactivate();
			}
		}
	}
	
	void UpdateActivation() override
	{
		if (mbManualActivation) return;
		cFearObject::UpdateActivation();
		
		if (mbFearActive == false) return;
		cVector3f vToPlayer = cLux_GetPlayer().GetCharacterBody().GetPosition() - GetEntity().GetPosition();
		if ((mbOnScreen && mbLos) || vToPlayer.Length() <= mfActivationDistance) mfDeactivationTimer = 0.0f;
	}
	
	void UpdateFearRateTarget() override
	{
		cFearObject::UpdateFearRateTarget();
		
		if (mbFearActive == false) return;
		if (mfOverrideFactor > 0.0f) return;
		
		mfHearFactorValue = GetHeardFactor();
		mfFearRateTarget += mfHearFactorValue;
	}
	
	float GetHeardFactor()
	{
		if (mfHeardTimer <= 0.0f) return 0.0f;
		if (GetLookAtFactor() > 0.0f) return 0.0f;
		float fActive = GetActiveFactor();
		if (fActive >= 0.1f) return 0.0f;
		if (fActive < 0.1f && fActive > 0.0f) return 0.1f - fActive;
		return 0.1f;
	}
	
	bool CanActivate() override
	{
		/////////////////////////////
		// Check if looked at
		if (mbOnScreen == false) return false;
		if (mbLos == false) return false;
		if (mbLit == false) return false;
		
		return true;
	}
	
	bool CanDeactivate() override
	{
		cVector3f vToPlayer = cLux_GetPlayer().GetCharacterBody().GetPosition() - GetEntity().GetPosition();
		if (vToPlayer.Length() > mfDeactivationDistance) return true;
		
		return false;
	}
	
	//------------------------------------------------------------
}
	
//----------------------------------------------------------------------------------------